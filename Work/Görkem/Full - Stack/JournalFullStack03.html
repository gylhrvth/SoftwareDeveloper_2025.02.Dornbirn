<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Express</title>
    <link rel="stylesheet" href="../Full - Stack/main02.css">
</head>
<body>
    <h1>Full - Stack</h1>
    <h2>Montag, 26. Mai 2025</h2>
    <h3>Express</h3>

<ul>
    <li class="textColor">
        <span class="underline">Was ist Express.js? Wozu wird es verwendet?</span>
        <p><b>Express.js</b> ist ein <b>minimalistisches und flexibles Webframework</b> f√ºr <b>Node.js,</b> das verwendet wird, um <b>Webanwendungen und APIs</b>  einfach und effizient zu erstellen.</p>
        <p><strong>üîß Wozu wird Express.js verwendet?</strong></p>
        <ul>
            <li><b>Server erstellen:</b> Express macht es einfach, einen Webserver mit Node.js zu erstellen.</li>
            <li><b>Routen verwalten: </b> Du kannst definieren, wie der Server auf verschiedene URL-Anfragen reagiert (GET, POST, etc.).</li>
            <li><b>Middleware nutzen:</b> Du kannst Funktionen zwischen Anfrage und Antwort einbauen (z.B. f√ºr Authentifizierung, Logging, CORS).</li>
            <li><b>APIs entwickeln:</b> H√§ufig in RESTful APIs verwendet.</li>
            <li><b>Templates rendern:</b> Unterst√ºtzung f√ºr Template-Engines wie EJS, Pug, etc.</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <p><span class="underline">Wie installiere ich Express.js in einem TypeScript-Projekt?</span></p>
        <ol>
            <li><b>‚úÖ Projekt initialisieren (falls noch nicht vorhanden):</b></li>
            <div class="code-box">
                <code>
                    npm init -y
                </code>
            </div><br>
            <li><b>‚úÖ TypeScript installiere (falls noch nicht installiert):</b></li>
            <div class="code-box">
                <code>
                    npm install typescript --save-dev
                </code>
            </div>
            <p>Erstelle eine <b>tsconfig.json</b> (falls nicht vorhanden):</p><br>
            <li><b>‚úÖ Express und Typen installieren:</b></li>
            <div class="code-box">
                <code>
                    npm install express
                    npm install @types/express --save-dev
                </code>
            </div>
            <p><b>@types/express</b> stellt die TypeScript-Typdefinitionen f√ºr Express bereit.</p><br>
            <li><b>‚úÖ Beispiel mit src/index.ts</b></li>
            <div class="code-box">
                <code>
                    import express, { Request, Response } from 'express';

                    const app = express();
                    const port = 3000;

                    app.get('/', (req: Request, res: Response) => {
                    res.send('Hello from Express + TypeScript!');
                    });

                    app.listen(port, () => {
                    console.log(`Server running at http://localhost:${port}`);
                    });
                </code>
            </div><br>
            <li><b>‚úÖ Kompilieren und starten:</b></li>
            <div class="code-box">
                <code>
                    npx tsc
                    node dist/index.js
                </code>
            </div>
        </ol>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie erstelle ich einen einfachen Web-Server mit Express?</span>
        <p><strong>üü¶ Express Web-Server in TypeScript</strong></p>
        <ol>
            <li><b>üîß Abh√§ngigkeiten installieren:</b></li>
            <div class="code-box">
                <code>
                    npm install express
                    npm install --save-dev typescript @types/node @types/express
                    npx tsc --init 
                </code>
            </div><br>
            <li><b>üìùProjektstruktur:</b></li>
            <div class="code-box">
                <code>
                    /src
                        index.ts
                    tsconfig.json
                </code>
            </div><br>
            <li><b>‚úçÔ∏è Inhalt von src/index.ts:</b></li>
            <div class="code-box">
                <code>
                    import express, { Request, Response } from 'express';

                    const app = express();
                    const port = 3000;

                    app.get('/', (req: Request, res: Response) => {
                    res.send('Hello from TypeScript + Express!');
                    });

                    app.listen(port, () => {
                    console.log(`Server l√§uft auf http://localhost:${port}`);
                    });
            </div><br>
            <li><b>tsconfig.json anpassen</b> (wichtig):</li>
            <div class="code-box">
                <code>
                    {
                    "compilerOptions": {
                        "target": "es6",
                        "module": "commonjs",
                        "rootDir": "./src",
                        "outDir": "./dist",
                        "strict": true,
                        "esModuleInterop": true
                        }   
                    }
                </code>
            </div><br>
            <li><b>‚ñ∂Ô∏è Kompilieren & Starten</b></li>
            <div class="code-box">
                <code>
                    npx tsc
                    node dist/index.js
                </code>
            </div>
        </ol>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Was ist dotenv und warum sollte man es verwenden?</span>
        <p><b>dotenv</b>  ist ein kleines, aber sehr n√ºtzliches Node.js-Modul, das verwendet wird, um <b>Umgebungsvariablen</b> aus einer .env-Datei zu laden. Es ist besonders wichtig f√ºr <b>Sicherheit, Konfiguration und sauberen Code.</b></p>
        <p><strong>üîß Was ist dotenv?</strong></p>
        <ul>
            <li>Eine Bibliothek, die .env-Dateien liest.</li>
            <li>L√§dt deren Inhalte in process.env, damit du in deinem Code auf sie zugreifen kannst.</li>
            <li>Wird vor allem in <b>Express/Node-Projekten</b> eingesetzt</li>
        </ul><br>
        <p><strong>üîí Warum sollte man dotenv verwenden?</strong></p>
        <table class="sql-table">
            <thead>
                <tr>
                    <th>Vorteil</th>
                    <th>Erkl√§rung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Sicherheit</td>
                    <td>Versteckt sensible Daten (z.B. API-Keys, Passw√∂rter)</td>
                </tr>
                <tr>
                    <td>Einfache Konfiguration</td>
                    <td>Trennt Konfiguration vom Code</td>
                </tr>
                <tr>
                    <td>Keine Hardcoded Werte</td>
                    <td>Kein fest eingetragener Port, keine DB-Logins im Code</td>
                </tr>
                <tr>
                    <td>Umgebungen trennen</td>
                    <td>Z.B. unterschiedliche Einstellungen f√ºr Entwicklung & Produktion</td>
                </tr>
            </tbody>
        </table><br>
        <p><strong>Beispiel .env Datei:</strong></p>
        <div class="code-box">
            <code>
                PORT=3000
                DB_HOST=localhost
                API_KEY=123456789
            </code>
        </div><br>
        <p><strong>Installation:</strong></p>
        <div class="code-box">
            <code>
                npm install dotenv
            </code>
        </div><br>
        <p><strong>üßæ Verwendung in index.js / app.js</strong></p>
        <div class="code-box">
            <code>
                require('dotenv').config(); // muss ganz oben stehen

                const express = require('express');
                const app = express();

                const port = process.env.PORT || 3000;

                app.get('/', (req, res) => {
                res.send('API-Key: ' + process.env.API_KEY);
                });

                app.listen(port, () => {
                console.log(`Server l√§uft auf http://localhost:${port}`);
                });
            </code>
        </div><br>
        <p><strong>üí° Wichtiger Hinweis:</strong></p>
        <ul>
            <li>F√ºge sie zur .gitignore hinzu:</li>
            <li>Die .env-Datei nie in Git hochladen!</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie definiere ich Routes in Express?</span>
        <p>In <b>Express.js</b> definierst du <b>Routen</b>, um festzulegen, wie dein Server auf <b>HTTP-Anfragen</b> reagiert - z.B. GET, POST, PUT oder DELETE.</p>
        <p><strong>üîπ Grundstruktur:</strong></p>
        <div class="code-box">
            <code>
                app.METHODE('/pfad', (req, res) => {
                    // Was passieren soll
                });
            </code>
        </div><br>
        <p><strong>üí° Wichtige Methoden:</strong></p>
        <table class="sql-table">
            <thead>
                <tr>
                    <th>Methode</th>
                    <th>Beschreibung</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>app.get()</td>
                    <td>Daten abrufen</td>
                </tr>
                <tr>
                    <td>app.post()</td>
                    <td>Neue Daten senden</td>
                </tr>
                <tr>
                    <td>app.put()</td>
                    <td>Vorhandene Daten aktualisieren</td>
                </tr>
                <tr>
                    <td>app.delete()</td>
                    <td>Daten l√∂schen</td>
                </tr>
            </tbody>
        </table><br>
        <p><strong>Beispiele:</strong></p>
        <p>üü¢ GET-Route:</p>
        <div class="code-box">
            <code>
                app.get('/', (req, res) => {
                res.send('Startseite');
                });
            </code>
        </div><br>
        <p>üü° POST-Route:</p>
        <div class="code-box">
            <code>
                app.post('/user', (req, res) => {
                const name = req.body.name;
                res.send(`Benutzer ${name} erstellt`);
                }); 
            </code>
        </div><br>
        <p>üîµ Route mit URL-Parameter:</p>
        <div class="code-box">
            <code>
                app.get('/user/:id', (req, res) => {
                res.send(`Benutzer-ID: ${req.params.id}`);
                });
            </code>
        </div><br>
        <p><strong>üîÅ Mehrere Methoden auf einer Route:</strong></p>
        <div class="code-box">
            <code>
                app.route('/artikel')
                .get((req, res) => res.send('Alle Artikel'))
                .post((req, res) => res.send('Artikel erstellt'));
            </code>
        </div>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie kann ich statische Dateien mit Express bereitstellen?</span>
        <p>In <b>Express.js</b> kannst du <b>statische Dateien</b> wie HTML, CSS, Bilder oder JavaScript mit der Middleware <code>express.static</code> bereitstellen.</p>
        <p><strong>üìÅ Projektstruktur:</strong></p>
        <div class="code-box">
            <code>
                projekt/<br>
                ‚îú‚îÄ‚îÄ public/<br>
                ‚îÇ   ‚îú‚îÄ‚îÄ index.html<br>
                ‚îÇ   ‚îú‚îÄ‚îÄ style.css<br>
                ‚îÇ   ‚îî‚îÄ‚îÄ script.js<br>
                ‚îî‚îÄ‚îÄ app.js
            </code>
        </div><br>

        <p><strong>‚úÖ Express-Konfiguration:</strong></p>
        <div class="code-box">
            <code>
                const express = require('express');<br>
                const app = express();<br><br>

                app.use(express.static('public'));<br><br>

                app.listen(3000, () => {<br>
                &nbsp;&nbsp;console.log('Server l√§uft auf http://localhost:3000');<br>
                });
            </code>
        </div><br>

        <p><strong>üåê Zugriff im Browser:</strong></p>
        <ul>
            <li><code>http://localhost:3000/index.html ‚Üí l√§dt deine HTML-Datei</code></li>
            <li><code>http://localhost:3000/style.css ‚Üí liefert dein CSS</code></li>
            <li><code>http://localhost:3000/script.js ‚Üí liefert dein JS</code></li>
        </ul><br>

        <p><strong>üí° Optional mit URL-Pr√§fix:</strong></p>
        <div class="code-box">
            <code>
                app.use('/static', express.static('public'));
            </code>
        </div>
        <p>Dann erreichbar unter z.B.: <code>/static/index.html</code></p>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie kann ich eine JSON als REST API als Ergebnis bereitstellen?</span>
        <p>Mit <b>Express.js</b> kannst du eine <b>JSON-Antwort</b> ganz einfach √ºber <code>res.json()</code> bereitstellen. Das ist die Standardmethode, um REST APIs zu entwickeln.</p>
        <p><strong>üì¶ Beispiel:</strong></p>
        <div class="code-box">
            <code>
                const express = require('express');<br>
                const app = express();<br><br>

                app.get('/api/user', (req, res) => {<br>
                &nbsp;&nbsp;res.json({<br>
                &nbsp;&nbsp;&nbsp;&nbsp;id: 1,<br>
                &nbsp;&nbsp;&nbsp;&nbsp;name: 'Max Mustermann',<br>
                &nbsp;&nbsp;&nbsp;&nbsp;email: 'max@example.com'<br>
                &nbsp;&nbsp;});<br>
                });<br><br>

                app.listen(3000, () => {<br>
                &nbsp;&nbsp;console.log('API l√§uft auf http://localhost:3000');<br>
                });
            </code>
        </div><br>

        <p><strong>üß† Ergebnis im Browser oder Postman:</strong></p>
        <div class="code-box">
            <code>
                {<br>
                &nbsp;&nbsp;"id": 1,<br>
                &nbsp;&nbsp;"name": "Max Mustermann",<br>
                &nbsp;&nbsp;"email": "max@example.com"<br>
                }
            </code>
        </div><br>

        <p><strong>üìå Typische REST-API-Pfade:</strong></p>
        <table class="sql-table">
            <thead>
            <tr>
                <th>Methode</th>
                <th>Pfad</th>
                <th>Beschreibung</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>GET</td>
                <td>/api/users</td>
                <td>Alle Benutzer abrufen</td>
            </tr>
            <tr>
                <td>POST</td>
                <td>/api/users</td>
                <td>Neuen Benutzer hinzuf√ºgen</td>
            </tr>
            <tr>
                <td>GET</td>
                <td>/api/users/:id</td>
                <td>Benutzer mit bestimmter ID abrufen</td>
            </tr>
            </tbody>
        </table><br>

        <p><strong>‚úÖ Merke:</strong></p>
        <ul>
            <li><code>res.json()</code> sendet automatisch g√ºltige JSON-Daten.</li>
            <li>Du kannst Objekte, Arrays oder gemischte Daten senden.</li>
            <li>Ideal f√ºr APIs, die mit Frontend-Apps oder externen Tools kommunizieren.</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie kann ich eine generierte HTML Dokument als Ergebnis bereitstellen?</span>
        <p>In <b>Express.js</b> kannst du HTML entweder als Datei oder direkt als Text senden.</p>

        <p><strong>üìÅ 1. HTML-Datei senden mit <code>res.sendFile()</code>:</strong></p>
        <div class="code-box">
            <code>
                const path = require('path');<br><br>

                app.get('/seite', (req, res) => {<br>
                &nbsp;&nbsp;res.sendFile(path.join(__dirname, 'views', 'seite.html'));<br>
                });
            </code>
        </div><br>

        <p><strong>üì§ 2. Direktes HTML senden mit <code>res.send()</code>:</strong></p>
        <div class="code-box">
            <code>
                app.get('/', (req, res) => {<br>
                &nbsp;&nbsp;res.send(`&lt;html&gt;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hallo Welt&lt;/h1&gt;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;HTML-Antwort vom Server&lt;/p&gt;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;<br>
                &nbsp;&nbsp;&lt;/html&gt;`);<br>
                });
            </code>
        </div><br>

        <p><strong>üõ† 3. Mit Template-Engine (z.B. EJS):</strong></p>
        <div class="code-box">
            <code>
                app.set('view engine', 'ejs');<br>
                app.get('/profil', (req, res) => {<br>
                &nbsp;&nbsp;res.render('profil', { name: 'Max' });<br>
                });
            </code>
        </div><br>

        <p><strong>‚úÖ Zusammenfassung:</strong></p>
        <ul>
            <li><code>res.sendFile()</code> ‚Üí HTML-Datei senden</li>
            <li><code>res.send()</code> ‚Üí Direkt HTML zur√ºckgeben</li>
            <li><code>res.render()</code> ‚Üí Dynamisches HTML mit Template-Engine</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie behandle ich HTTP-Anfragen (GET, POST, etc.)?</span>
        <p>In <b>Express.js</b> definierst du Funktionen, die auf <b>HTTP-Anfragen</b> wie <code>GET</code>, <code>POST</code>, <code>PUT</code> und <code>DELETE</code> reagieren. Jede Methode hat ihren eigenen Zweck.</p>

        <p><strong>üìå Syntax:</strong></p>
        <div class="code-box">
            <code>
                app.METHODE('/pfad', (req, res) => {<br>
                &nbsp;&nbsp;// Was soll passieren?<br>
                });
            </code>
        </div><br>

        <p><strong>üßæ √úberblick √ºber HTTP-Methoden:</strong></p>
        <table class="sql-table">
            <thead>
                <tr>
                    <th>Methode</th>
                    <th>Verwendung</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>GET</td>
                    <td>Daten vom Server abrufen</td>
                </tr>
                <tr>
                    <td>POST</td>
                    <td>Neue Daten an den Server senden</td>
                </tr>
                <tr>
                    <td>PUT</td>
                    <td>Vorhandene Daten vollst√§ndig ersetzen</td>
                </tr>
                <tr>
                    <td>PATCH</td>
                    <td>Daten teilweise aktualisieren</td>
                </tr>
                <tr>
                    <td>DELETE</td>
                    <td>Daten vom Server l√∂schen</td>
                </tr>
            </tbody>
        </table><br>

        <p><strong>üü¢ Beispiel: GET-Anfrage</strong></p>
        <div class="code-box">
            <code>
                app.get('/api/user', (req, res) => {<br>
                &nbsp;&nbsp;res.send('Benutzerdaten');<br>
                });
            </code>
        </div><br>

        <p><strong>üü° Beispiel: POST-Anfrage</strong></p>
        <div class="code-box">
            <code>
            app.use(express.json());<br><br>

            app.post('/api/user', (req, res) => {<br>
            &nbsp;&nbsp;const user = req.body;<br>
            &nbsp;&nbsp;res.send(`Neuer Benutzer: ${user.name}`);<br>
            });
            </code>
        </div><br>

        <p><strong>üõ† Hinweis:</strong> Um JSON-Daten im Body zu empfangen, musst du <code>express.json()</code> aktivieren.</p>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie kann ich Query-Parameter und URL-Parameter verarbeiten?</span>
        <p>In <b>Express.js</b> kannst du mit <code>req.params</code> und <code>req.query</code> auf Daten in der URL zugreifen.</p>

        <p><strong>üîπ URL-Parameter:</strong> Bestandteil der URL - z.B. <code>/user/42</code></p>
        <div class="code-box">
            <code>
                app.get('/user/:id', (req, res) => {<br>
                &nbsp;&nbsp;const userId = req.params.id;<br>
                &nbsp;&nbsp;res.send(`Benutzer-ID: ${userId}`);<br>
                });
            </code>
        </div><br>

        <p><strong>üîπ Query-Parameter:</strong> √úbergeben nach dem <code>?</code> in der URL - z.B. <code>/search?name=Lisa</code></p>
        <div class="code-box">
            <code>
                app.get('/search', (req, res) => {<br>
                &nbsp;&nbsp;const name = req.query.name;<br>
                &nbsp;&nbsp;res.send(`Gesuchter Name: ${name}`);<br>
                });
            </code>
        </div><br>

        <p><strong>üîÅ Kombination von beiden:</strong></p>
        <div class="code-box">
            <code>
                // URL: /product/88?lang=de<br>
                app.get('/product/:id', (req, res) => {<br>
                &nbsp;&nbsp;const id = req.params.id;<br>
                &nbsp;&nbsp;const lang = req.query.lang;<br>
                &nbsp;&nbsp;res.send(`Produkt: ${id}, Sprache: ${lang}`);<br>
                });
            </code>
        </div><br>

        <p><strong>‚úÖ Zusammenfassung:</strong></p>
        <ul>
            <li><code>req.params</code> ‚Üí Zugriff auf URL-Teile wie <code>/user/:id</code></li>
            <li><code>req.query</code> ‚Üí Zugriff auf <code>?key=value</code>-Paare</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie kann ich Body eines Query lesen?</span>
        <p>Um den <b>Body</b> von Anfragen wie <code>POST</code> oder <code>PUT</code> in <b>Express.js</b> zu lesen, musst du einen <b>Body-Parser</b> aktivieren ‚Äì meist mit <code>express.json()</code>.</p>

        <p><strong>üì¶ JSON-Daten lesen:</strong></p>
        <div class="code-box">
            <code>
                app.use(express.json()); // aktiviert JSON-Parsing
            </code>
        </div><br>

        <p><strong>üì© Beispiel: POST-Anfrage mit JSON</strong></p>
        <div class="code-box">
            <code>
                app.post('/login', (req, res) => {<br>
                &nbsp;&nbsp;const username = req.body.username;<br>
                &nbsp;&nbsp;const password = req.body.password;<br>
                &nbsp;&nbsp;res.send(`Willkommen ${username}`);<br>
                });
            </code>
        </div><br>

        <p><strong>üì® F√ºr Formulare (URL-encoded):</strong></p>
        <div class="code-box">
            <code>
                app.use(express.urlencoded({ extended: true }));
            </code>
        </div><br>

        <p><strong>üß™ Beispiel mit Formular:</strong></p>
        <div class="code-box">
            <code>
                &lt;form method="POST" action="/kontakt"&gt;<br>
                &nbsp;&nbsp;&lt;input name="email" /&gt;<br>
                &nbsp;&nbsp;&lt;input name="nachricht" /&gt;<br>
                &lt;/form&gt;
            </code>
        </div>

        <div class="code-box">
            <code>
                app.post('/kontakt', (req, res) => {<br>
                &nbsp;&nbsp;const email = req.body.email;<br>
                &nbsp;&nbsp;res.send(`Danke, Nachricht von ${email}`);<br>
                });
            </code>
        </div><br>

        <p><strong>‚úÖ Zusammenfassung:</strong></p>
        <ul>
            <li><code>express.json()</code> ‚Üí f√ºr JSON-Daten</li>
            <li><code>express.urlencoded({ extended: true })</code> ‚Üí f√ºr HTML-Formulare</li>
            <li>Dann kannst du mit <code>req.body</code> auf die Daten zugreifen</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Was kann ich als Body in einem Query bekommen?</span>
        <p>Im <b>Request Body</b> kannst du verschiedene Arten von Daten empfangen, z.B. bei <code>POST</code>-, <code>PUT</code>- oder <code>PATCH</code>-Anfragen. Diese Daten werden vom Client (Browser, API-Client etc.) an den Server gesendet.</p>

        <p><strong>üì• √úbliche Inhalte im Body:</strong></p>
        <ul>
            <li><code>JSON</code> - h√§ufig bei modernen Web-APIs</li>
            <li><code>x-www-form-urlencoded</code> - Standard bei HTML-Formularen</li>
            <li><code>multipart/form-data</code> - f√ºr Datei-Uploads</li>
            <li><code>Text</code> oder <code>XML</code> - in Spezialf√§llen</li>
        </ul>

        <p><strong>üü¢ Beispiel: JSON-Daten</strong></p>
        <p>Request:</p>
        <div class="code-box">
            <code>
                POST /api/user<br>
                Content-Type: application/json<br><br>

                { "name": "Ali", "email": "ali@example.com" }
            </code>
        </div>
        <p>Server:</p>
        <div class="code-box">
            <code>
                app.use(express.json());<br><br>
                app.post('/api/user', (req, res) => {<br>
                &nbsp;&nbsp;const name = req.body.name;<br>
                &nbsp;&nbsp;res.send(`Name: ${name}`);<br>
                });
            </code>
        </div><br>

        <p><strong>üü° Beispiel: Formulardaten (URL-encoded)</strong></p>
        <div class="code-box">
            <code>
                email=ali%40example.com&message=Hallo+Welt
            </code>
        </div>
        <p>Middleware:</p>
        <div class="code-box">
            <code>
                app.use(express.urlencoded({ extended: true }));
            </code>
        </div><br>

        <p><strong>üì¶ Zusammenfassung:</strong></p>
        <ul>
            <li>Body enth√§lt strukturierte Daten vom Client</li>
            <li><code>req.body</code> wird durch Middleware lesbar</li>
            <li>Datentyp h√§ngt vom <code>Content-Type</code> im Header ab</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Was sind Middleware-Funktionen in Express?</span>
         <p>Middleware sind Funktionen, die <b>zwischen der Anfrage (Request) und der Antwort (Response)</b> ausgef√ºhrt werden. Sie haben Zugriff auf <code>req</code>, <code>res</code> und k√∂nnen den Ablauf steuern, z.B. Daten verarbeiten, Anfragen pr√ºfen oder den Request weiterleiten.</p>

        <p><strong>üîπ Aufgaben von Middleware:</strong></p>
        <ul>
            <li>Request-Daten verarbeiten (z.B. Body parsen)</li>
            <li>Authentifizierung & Autorisierung pr√ºfen</li>
            <li>Logging und Fehlerbehandlung</li>
            <li>Statische Dateien bereitstellen</li>
            <li>Weiterleitung an n√§chste Middleware oder Route</li>
        </ul>

        <p><strong>üî∏ Middleware-Aufbau:</strong></p>
        <div class="code-box">
            <code>
                function middlewareName(req, res, next) {<br>
                &nbsp;&nbsp;// Verarbeitung<br>
                &nbsp;&nbsp;next(); // Weiter zur n√§chsten Middleware / Route<br>
                }
            </code>
        </div><br>

        <p><strong>üîπ Middleware einbinden:</strong></p>
        <div class="code-box">
            <code>
                app.use(middlewareName);
            </code>
        </div><br>

        <p><strong>üü¢ Beispiel: JSON-Body-Parser Middleware</strong></p>
        <div class="code-box">
            <code>
                app.use(express.json());
            </code>
        </div>

        <p><strong>üü° Beispiel: Eigene Middleware zur Anfrage-Log:</strong></p>
        <div class="code-box">
            <code>
                app.use((req, res, next) => {<br>
                &nbsp;&nbsp;console.log(`${req.method} ${req.url}`);<br>
                &nbsp;&nbsp;next();<br>
                });
            </code>
        </div><br>

        <p><strong>‚úÖ Zusammenfassung:</strong></p>
        <ul>
            <li>Middleware sind Ketten von Funktionen, die Anfragen bearbeiten</li>
            <li>Sie erm√∂glichen modulare und wiederverwendbare Logik</li>
            <li>Sie k√∂nnen den Request ver√§ndern oder die Antwort vorbereiten</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Wie implementiere ich Error-Handling in Express?</span>
         <p>In Express wird Error-Handling mit spezieller Middleware umgesetzt, die vier Parameter erh√§lt: <code>(err, req, res, next)</code>. So kann man Fehler zentral erfassen und darauf reagieren.</p>

        <p><strong>üîπ Aufbau einer Error-Handling Middleware:</strong></p>
        <div class="code-box">
            <code>
                function errorHandler(err, req, res, next) {<br>
                &nbsp;&nbsp;console.error(err.stack);<br>
                &nbsp;&nbsp;res.status(500).send('Interner Serverfehler');<br>
                }
            </code>
        </div><br>

        <p><strong>üîπ Einbinden der Middleware:</strong></p>
        <div class="code-box">
            <code>
                app.use(errorHandler);
            </code>
        </div><br>

        <p><strong>üü¢ Beispiel: Fehler ausl√∂sen und behandeln</strong></p>
        <div class="code-box">
            <code>
                app.get('/error', (req, res, next) => {<br>
                &nbsp;&nbsp;const err = new Error('Etwas ist schiefgelaufen');<br>
                &nbsp;&nbsp;next(err); // Fehler an Error-Middleware weitergeben<br>
                });
            </code>
        </div><br>

        <p><strong>‚úÖ Zusammenfassung:</strong></p>
        <ul>
            <li>Error-Middleware hat immer 4 Parameter: <code>err, req, res, next</code></li>
            <li>Fehler werden mit <code>next(err)</code> weitergeleitet</li>
            <li>Zentrale Fehlerbehandlung sorgt f√ºr sauberen Code und bessere Wartbarkeit</li>
        </ul>
    </li>
    <br>
    <br>

    <li class="textColor">
        <span class="underline">Was sind die Best Practices f√ºr die Strukturierung einer Express-Anwendung?</span>
        <p>Eine gut strukturierte Express-App ist leichter wartbar, skalierbar und verst√§ndlich. Hier sind bew√§hrte Methoden:</p>

        <p><strong>üîπ 1. Projektstruktur modular aufbauen:</strong></p>
        <ul>
            <li><code>app.js</code> oder <code>server.js</code> f√ºr Hauptsetup und Middleware</li>
            <li><code>/routes</code>-Ordner f√ºr alle Routen</li>
            <li><code>/controllers</code> f√ºr Logik der Routen</li>
            <li><code>/models</code> f√ºr Datenbank-Modelle (z.B. mit Mongoose, Sequelize)</li>
            <li><code>/middleware</code> f√ºr eigene Middleware-Funktionen</li>
            <li><code>/public</code> f√ºr statische Dateien (CSS, JS, Bilder)</li>
            <li><code>/utils</code> oder <code>/helpers</code> f√ºr Hilfsfunktionen</li>
        </ul>

        <p><strong>üîπ 2. Routen und Controller trennen:</strong></p>
        <p>Routen definieren URLs und HTTP-Methoden, Controller implementieren die eigentliche Logik.</p>

        <p><strong>üîπ 3. Middleware gezielt einsetzen:</strong></p>
        <ul>
            <li>Body-Parser, Authentifizierung, Fehlerhandling etc. als Middleware</li>
            <li>Middleware in <code>app.js</code> zentral einbinden</li>
        </ul>

        <p><strong>üîπ 4. Umgebungsvariablen verwenden:</strong></p>
        <p>Konfigurationen wie Ports, Datenbank-URLs mit <code>dotenv</code> verwalten.</p>

        <p><strong>üîπ 5. Fehlerbehandlung zentralisieren:</strong></p>
        <p>Error-Middleware f√ºr sauberes Fehlerhandling.</p>

        <p><strong>üîπ 6. Saubere Trennung von Frontend und Backend:</strong></p>
        <p>Falls Frontend nicht direkt mit Express gerendert wird, statische Dateien oder API-Endpunkte klar trennen.</p>

        <p><strong>üü¢ Beispiel Projektstruktur:</strong></p>
        <div class="code-box">
            <code>
                /project-root<br>
                ‚îú‚îÄ‚îÄ app.js<br>
                ‚îú‚îÄ‚îÄ /routes<br>
                ‚îÇ&nbsp;&nbsp;userRoutes.js<br>
                ‚îÇ&nbsp;&nbsp;productRoutes.js<br>
                ‚îú‚îÄ‚îÄ /controllers<br>
                ‚îÇ&nbsp;&nbsp;userController.js<br>
                ‚îÇ&nbsp;&nbsp;productController.js<br>
                ‚îú‚îÄ‚îÄ /models<br>
                ‚îú‚îÄ‚îÄ /middleware<br>
                ‚îú‚îÄ‚îÄ /public<br>
                ‚îú‚îÄ‚îÄ /utils<br>
                ‚îî‚îÄ‚îÄ .env
            </code>
        </div>

    <p><strong>‚úÖ Zusammenfassung:</strong></p>
    <ul>
        <li>Modular und √ºbersichtlich strukturieren</li>
        <li>Routen, Controller und Middleware klar trennen</li>
        <li>Konfigurationen auslagern (z. B. .env)</li>
        <li>Fehler zentral behandeln</li>
    </ul>
</li>
<br>
<br>

<li class="textColor">
    <span class="underline">Wie stelle ich die Sicherheit meiner Express-Anwendung sicher?</span>
    <p>Die Sicherheit einer Express-App ist essenziell, um Daten zu sch√ºtzen und Angriffe zu verhindern. Hier sind wichtige Ma√ünahmen:</p>

    <p><strong>üîπ 1. Verwende HTTPS</strong><br>
    Daten sollten immer verschl√ºsselt √ºbertragen werden, z.B. mit SSL/TLS-Zertifikaten.</p>

    <p><strong>üîπ 2. Setze Sicherheits-Header mit <code>helmet</code></strong><br>
    <code>helmet</code> ist eine Middleware, die g√§ngige HTTP-Sicherheits-Header setzt.</p>
    <div class="code-box">
        <code>
            const helmet = require('helmet');<br>
            app.use(helmet());
        </code>
    </div>

    <p><strong>üîπ 3. Sch√ºtze dich vor Cross-Site Scripting (XSS) und Injection</strong><br>
    - Validierung und Sanitizing von Nutzereingaben<br>
    - Verwendung von ORM/Query-Buildern zum Schutz vor SQL-Injection</p>

    <p><strong>üîπ 4. Rate Limiting</strong><br>
    Beschr√§nke Anfragen pro IP, um Brute-Force-Angriffe zu vermeiden.</p>

    <p><strong>üîπ 5. Authentifizierung und Autorisierung sicher implementieren</strong><br>
    - Passw√∂rter niemals im Klartext speichern (bcrypt verwenden)<br>
    - JSON Web Tokens (JWT) oder Sessions sicher einsetzen</p>

    <p><strong>üîπ 6. Umgang mit sensiblen Daten</strong><br>
    Umgebungsvariablen (.env) nutzen, keine sensiblen Daten im Code speichern.</p>

    <p><strong>üîπ 7. CORS richtig konfigurieren</strong><br>
    Nur vertrauensw√ºrdige Domains Zugriff erlauben.</p>

    <p><strong>üü¢ Beispiel: Einfache Sicherheits-Middleware</strong></p>
    <div class="code-box">
        <code>
            const helmet = require('helmet');<br>
            const rateLimit = require('express-rate-limit');<br><br>

            app.use(helmet());<br><br>

            const limiter = rateLimit({<br>
            &nbsp;&nbsp;windowMs: 15 * 60 * 1000, // 15 Minuten<br>
            &nbsp;&nbsp;max: 100 // max. 100 Anfragen pro IP<br>
            });<br><br>

            app.use(limiter);
        </code>
    </div><br>

    <p><strong>‚úÖ Zusammenfassung:</strong></p>
    <ul>
        <li>Sichere Kommunikation mit HTTPS</li>
        <li>Schutz durch HTTP-Header (helmet)</li>
        <li>Validierung und Schutz vor Injection-Attacken</li>
        <li>Begrenzung von Anfragen (Rate Limiting)</li>
        <li>Sichere Authentifizierung und Umgang mit Passw√∂rtern</li>
        <li>Sensible Daten nicht im Code speichern</li>
        <li>CORS nur f√ºr vertrauensw√ºrdige Quellen √∂ffnen</li>
    </ul>
</li>
<br>
<br>

<li class="textColor">
    <span class="underline">Wie stelle ich die Sicherheit meiner Express-Anwendung sicher?</span>
    <p>Die Sicherheit einer Express-Anwendung ist entscheidend, um Angriffe zu verhindern und Daten zu sch√ºtzen. Folgende Best Practices helfen dabei:</p>

    <p><strong>üîπ HTTPS verwenden:</strong> Sichere Daten√ºbertragung durch SSL/TLS-Zertifikate.</p>

    <p><strong>üîπ Sicherheits-Header mit <code>helmet</code> setzen:</strong> 
    <code>helmet</code> sch√ºtzt vor vielen Angriffen durch das Setzen von HTTP-Sicherheitsheadern.</p>
    <div class="code-box">
        <code>
            const helmet = require('helmet');<br>
            app.use(helmet());
        </code>
    </div>

    <p><strong>üîπ Eingaben validieren und sanitizen:</strong> Sch√ºtze vor XSS- und Injection-Angriffen durch saubere Datenverarbeitung.</p>

    <p><strong>üîπ Rate Limiting:</strong> Begrenze die Anzahl von Anfragen pro IP, um Brute-Force-Attacken zu verhindern.</p>

    <p><strong>üîπ Sichere Authentifizierung:</strong> Passw√∂rter hashen (z.B. mit bcrypt) und sichere Token verwenden (z.B. JWT).</p>

    <p><strong>üîπ Umgebungsvariablen f√ºr sensible Daten:</strong> Keine Passw√∂rter oder Schl√ºssel im Code speichern, sondern in .env-Dateien.</p>

    <p><strong>üîπ CORS konfigurieren:</strong> Beschr√§nke den Zugriff auf vertrauensw√ºrdige Domains.</p>

    <p><strong>üü¢ Beispiel Sicherheits-Middleware:</strong></p>
    <div class="code-box">
        <code>
            const helmet = require('helmet');<br>
            const rateLimit = require('express-rate-limit');<br><br>

            app.use(helmet());<br><br>

            const limiter = rateLimit({<br>
            &nbsp;&nbsp;windowMs: 15 * 60 * 1000, // 15 Minuten<br>
            &nbsp;&nbsp;max: 100 // max. 100 Anfragen pro IP<br>
            });<br><br>

            app.use(limiter);
        </code>
    </div>

    <p><strong>‚úÖ Zusammenfassung:</strong></p>
    <ul>
        <li>HTTPS f√ºr sichere Kommunikation</li>
        <li>Sicherheits-Header mit <code>helmet</code></li>
        <li>Eingaben validieren und sanitizen</li>
        <li>Rate Limiting zum Schutz vor Angriffen</li>
        <li>Sichere Authentifizierung und Passwort-Hashing</li>
        <li>Sensible Daten in Umgebungsvariablen auslagern</li>
        <li>CORS nur f√ºr vertrauensw√ºrdige Quellen √∂ffnen</li>
    </ul>
</li>
<br>
<br>

<li class="textColor">
    <span class="underline">Wie integriere ich Express mit einer Datenbank?</span>
    <p>Um eine Datenbank in Express einzubinden, verbindet man den Server mit der Datenbank, um Daten zu speichern, abzufragen oder zu √§ndern.</p>

    <p><strong>üîπ 1. W√§hle eine Datenbank:</strong> z.B. relationale DB (MySQL, PostgreSQL) oder NoSQL (MongoDB).</p>

    <p><strong>üîπ 2. Installiere passende Node.js-Module:</strong><br>
    - F√ºr MongoDB z.B. <code>mongoose</code> oder <code>mongodb</code><br>
    - F√ºr MySQL z.B. <code>mysql2</code> oder <code>sequelize</code> (ORM)<br>
    - F√ºr PostgreSQL z.B. <code>pg</code> oder <code>sequelize</code></p>

    <p><strong>üîπ 3. Verbindung zur Datenbank herstellen:</strong></p>
    <div class="code-box">
        <code>
            // Beispiel MongoDB mit Mongoose<br>
            const mongoose = require('mongoose');<br>
            mongoose.connect(process.env.DB_URI, { useNewUrlParser: true, useUnifiedTopology: true })<br>
            &nbsp;&nbsp;.then(() => console.log('DB connected'))<br>
            &nbsp;&nbsp;.catch(err => console.error(err));
        </code>
    </div>

    <p><strong>üîπ 4. Datenbankmodelle definieren:</strong> z.B. mit Mongoose Schemas oder Sequelize Models.</p>

    <p><strong>üîπ 5. In Express-Routen Datenbank-Operationen durchf√ºhren:</strong><br>
    Daten erstellen, lesen, aktualisieren, l√∂schen (CRUD).</p>

    <p><strong>üü¢ Einfaches Beispiel einer Route mit Datenbankzugriff (MongoDB):</strong></p>
    <div class="code-box">
        <code>
            const express = require('express');<br>
            const router = express.Router();<br>
            const User = require('../models/user'); // Mongoose Model<br><br>

            router.get('/users', async (req, res) => {<br>
            &nbsp;&nbsp;try {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const users = await User.find();<br>
            &nbsp;&nbsp;&nbsp;&nbsp;res.json(users);<br>
            &nbsp;&nbsp;} catch (err) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;res.status(500).send('Server Error');<br>
            &nbsp;&nbsp;}<br>
            });<br><br>
            module.exports = router;
        </code>
    </div>

    <p><strong>‚úÖ Zusammenfassung:</strong></p>
    <ul>
        <li>Passende DB und Node-Module ausw√§hlen</li>
        <li>DB-Verbindung im Server aufbauen</li>
        <li>Datenmodelle definieren</li>
        <li>CRUD-Operationen in Express-Routen implementieren</li>
    </ul>
</li>
<br>
<br>

<li class="textColor">
    <span class="underline">Wie kann ich eine Webserver erstellen, der HTTPS unterst√ºtzt?</span>
    <p>Um HTTPS in einem Express-Webserver zu verwenden, brauchst du ein SSL/TLS-Zertifikat und einen privaten Schl√ºssel.</p>

    <p><strong>üîπ 1. SSL-Zertifikat und Key besorgen:</strong><br>
    - F√ºr Entwicklung: Self-Signed Zertifikat generieren (z.B. mit OpenSSL)<br>
    - F√ºr Produktion: Zertifikate von vertrauensw√ºrdigen CAs (z.B. Let's Encrypt)</p>

    <p><strong>üîπ 2. Node.js HTTPS-Modul verwenden:</strong> Express l√§uft zusammen mit dem <code>https</code>-Modul.</p>

    <p><strong>üîπ 3. Beispiel-Code f√ºr HTTPS-Server mit Express:</strong></p>
    <div class="code-box">
        <code>
            const https = require('https');<br>
            const fs = require('fs');<br>
            const express = require('express');<br>
            const app = express();<br><br>

            const options = {<br>
            &nbsp;&nbsp;key: fs.readFileSync('pfad/zum/private.key'),<br>
            &nbsp;&nbsp;cert: fs.readFileSync('pfad/zum/certificate.crt')<br>
            };<br><br>

            app.get('/', (req, res) => {<br>
            &nbsp;&nbsp;res.send('Hallo HTTPS!');<br>
            });<br><br>

            https.createServer(options, app).listen(443, () => {<br>
            &nbsp;&nbsp;console.log('HTTPS Server l√§uft auf Port 443');<br>
            });
        </code>
    </div>

    <p><strong>üîπ 4. Optional: HTTP auf HTTPS umleiten</strong><br>
    Um alle HTTP-Anfragen automatisch auf HTTPS weiterzuleiten, kannst du einen kleinen HTTP-Server einrichten:</p>
    <div class="code-box">
        <code>
            const http = require('http');<br>
            http.createServer((req, res) => {<br>
            &nbsp;&nbsp;res.writeHead(301, { 'Location': 'https://' + req.headers.host + req.url });<br>
            &nbsp;&nbsp;res.end();<br>
            }).listen(80);
        </code>
    </div>

    <p><strong>‚úÖ Zusammenfassung:</strong></p>
    <ul>
        <li>SSL-Zertifikat und privaten Schl√ºssel besorgen</li>
        <li>Express mit Node's <code>https</code>-Modul kombinieren</li>
        <li>HTTPS-Server mit Zertifikat und Key starten</li>
        <li>Optional HTTP-Anfragen auf HTTPS umleiten</li>
    </ul>
</li>
</ul>
</body>
</html>