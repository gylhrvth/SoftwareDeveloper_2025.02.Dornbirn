<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typescript Notes</title>
   
    <style>
/* General Layout */
body {
  background-color: #2e2d2d;
  color: #d0d0d0;
  font-family: Arial, sans-serif;
  margin: 2rem;
  line-height: 1.6;
}

/* Headings */
h1, h2 {
  color: #04ffff;
}
h3 {
  color: rgba(4, 255, 255, 0.765);
}

/* Links */
a {
  color: azure;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}

/* Lists */
ul, ol {
  padding-left: 1.5rem;
}
ul li, ol li {
  display: flex;
  justify-content: flex-start;
  width: max-content;
  background-color: rgba(0, 255, 255, 0.15);
  color: greenyellow;
  font-weight: bold;
  margin-bottom: 0.3rem;
}

/* Special Section List */
#Inhalt li {
  color: rgb(0, 255, 21);
  font-weight: bolder;
  font-family: 'Courier New', Courier, monospace;
}

/* Code & Pre Blocks */
code {
  background-color: rgb(255, 255, 255);
  color: rgb(12, 8, 3);
  padding: 0.2rem 0.4rem;
  border-radius: 4px;
  font-weight: bold;
}
pre {
  background-color: #afafaf;
  color: rgb(73, 174, 29);
  padding: 1rem;
  border-radius: 8px;
  overflow-x: auto;
  font-size: 1rem;
  font-family: 'Courier New', Courier, monospace;
}

/* Tables */
table {
  width: 100%;
  border-collapse: collapse;
  background-color: rgba(69, 101, 130, 0.6);
  color: white;
}
th, td {
  border: 2px solid rgba(0, 255, 255, 0.3);
  padding: 8px;
  text-align: left;
}

/* Utility Classes */
.highlight {
  background-color: rgba(255, 255, 0, 0.1);
  color: #ffff00;
  font-weight: bold;
}

.date-highlight {
  background-color: rgba(255, 255, 0, 0.1);
  color: #ffff00;
  font-weight: bold;
  width: max-content;
}
.note {
  background-color: rgba(0, 255, 255, 0.1);
  border-left: 5px solid cyan;
  padding: 0.5rem 1rem;
  margin: 1rem 0;
  color: #00ffee;
}
/* .code-block {
  background-color: #1a1a1a;
  border: 1px solid #555;
  padding: 1rem;
  border-radius: 6px;
  font-family: monospace;
  color: #ffa500;
} */


table code {
  background-color: #1a1a1a;
  border: 1px solid #555;
  padding: 0.5rem;
  border-radius: 6px;
  font-family: monospace;
  color: #ffa500;
}
.box {
  border: 1px solid rgba(0,255,255,0.3);
  padding: 1rem;
  background-color: rgba(0,0,0,0.2);
  border-radius: 6px;
  margin: 1rem 0;
}

/* Spacing Helpers */
.mt-1 { margin-top: 0.5rem; }
.mt-2 { margin-top: 1rem; }
.mb-1 { margin-bottom: 0.5rem; }
.mb-2 { margin-bottom: 1rem; }
.p-1 { padding: 0.5rem; }
.p-2 { padding: 1rem; }

    </style>
</head>
<body>
    <h1>Typescript</h1>
    <p class="date-highlight">Date 20.05.2025 </p>
<ol id="Inhalt">
  <li>Was ist TypeScript? Woher kommt es?</li>
  <li>Was sind die Vorteile / Nachteile von TypeScript gegen√ºber JavaScript?</li>
  <li>Wie erstelle ich ein Projekt mit TypeScript?</li>
  <li>Wie verwende ich Type Annotation f√ºr Variablen / Parameter / R√ºckgabewert?</li>
  <li>Wie beschreibe ich Arrays in TypeScript?</li>
  <li>Wie beschreibe ich Objekte in TypeScript?</li>
  <li>Wie verwende ich Interfaces in TypeScript?</li>
  <li>Wie verwende ich Type in TypeScript?</li>
  <li>Was ist der Unterschied zwischen Interface und Type in TypeScript?</li>
  <li>Wie verwende ich Union Types?</li>
  <li>Wie verwende ich Intersection Types?</li>
  <li>Was sind Generics? Wie verwende ich sie?</li>
  <li>Was sind enum in TypeScript? Wie verwende ich sie?</li>
</ol>
<h2>1. Was ist TypeScript? Woher kommt es?</h2>
<p>TypeScript ist eine von Microsoft entwickelte Programmiersprache, die auf JavaScript basiert und es erweitert. Es ist eine <strong>Supersprache</strong> von JavaScript, was bedeutet, dass jeder g√ºltige JavaScript-Code auch TypeScript-Code ist. TypeScript f√ºgt eine <strong>statische Typisierung</strong> hinzu, mit der Fehler schon beim Kompilieren erkannt werden k√∂nnen, statt erst zur Laufzeit.</p>
<ul>
  <li><strong>Entstehung:</strong> TypeScript wurde 2012 ver√∂ffentlicht, um gro√üe JavaScript-Projekte besser wartbar zu machen.</li>
  <li><strong>Ziel:</strong> Entwickler erhalten Werkzeuge zur Fehlervermeidung und bessere Entwicklungsunterst√ºtzung (Autovervollst√§ndigung, Refactoring).</li>
</ul>

<h2>2. Vorteile und Nachteile von TypeScript gegen√ºber JavaScript</h2>
<table>
  <thead>
    <tr>
      <th>Vorteile</th>
      <th>Nachteile</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Fr√ºherkennung von Fehlern durch Typpr√ºfung</td>
      <td>Zus√§tzlicher Kompilierungsschritt n√∂tig</td>
    </tr>
    <tr>
      <td>Bessere Code-Dokumentation durch Typen</td>
      <td>Lernkurve f√ºr Entwickler ohne Typ-Erfahrung</td>
    </tr>
    <tr>
      <td>Autovervollst√§ndigung & bessere IDE-Unterst√ºtzung</td>
      <td>Projektsetup etwas komplexer</td>
    </tr>
    <tr>
      <td>Bessere Wartbarkeit gro√üer Projekte</td>
      <td>Manchmal mehr Boilerplate-Code</td>
    </tr>
    <tr>
      <td>Unterst√ºtzt moderne JavaScript-Features vorzeitig</td>
      <td>Manchmal Probleme bei Integration mit JS-Bibliotheken</td>
    </tr>
  </tbody>
</table>

<h2>3. Wie erstelle ich ein Projekt mit TypeScript?</h2>
<p>Hier ist eine Schritt-f√ºr-Schritt Anleitung mit den n√∂tigen Befehlen:</p>
<table>
  <thead>
    <tr>
      <th>Schritt</th>
      <th>Befehl / Aktion</th>
      <th>Erkl√§rung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1. Ordner anlegen</td>
      <td><code>mkdir mein-ts-projekt</code></td>
      <td>Neuen Projektordner erstellen</td>
    </tr>
    <tr>
      <td>2. Ordner wechseln</td>
      <td><code>cd mein-ts-projekt</code></td>
      <td>In den Projektordner wechseln</td>
    </tr>
    <tr>
      <td>3. npm initialisieren</td>
      <td><code>npm init -y</code></td>
      <td>package.json erstellen (Standardkonfiguration)</td>
    </tr>
    <tr>
      <td>4. TypeScript installieren</td>
      <td><code>npm install typescript --save-dev</code></td>
      <td>TypeScript als Entwicklungsabh√§ngigkeit installieren</td>
    </tr>
    <tr>
      <td>5. tsconfig erstellen</td>
      <td><code>npx tsc --init</code></td>
      <td>TypeScript-Konfigurationsdatei (tsconfig.json) generieren</td>
    </tr>
    <tr>
      <td>6. Ordnerstruktur anlegen</td>
      <td><code>/src</code> und <code>/dist</code></td>
      <td>Quellcode (src) und Ausgabe (dist) strukturieren</td>
    </tr>
    <tr>
      <td>7. Beispielcode schreiben</td>
      <td>Datei <code>src/index.ts</code> anlegen</td>
      <td>TypeScript-Code schreiben, z.B. Funktion <code>greet()</code></td>
    </tr>
    <tr>
      <td>8. Kompilieren</td>
      <td><code>npx tsc</code></td>
      <td>TypeScript in JavaScript √ºbersetzen</td>
    </tr>
    <tr>
      <td>9. Ausf√ºhren</td>
      <td><code>node dist/index.js</code></td>
      <td>JavaScript-Code mit Node.js ausf√ºhren</td>
    </tr>
  </tbody>
</table>

<h2>4. Wie verwende ich Type Annotation f√ºr Variablen / Parameter / R√ºckgabewert?</h2>


  <p><strong>Was ist Type Annotation?</strong></p>
  <p>Type Annotation bedeutet, dass du explizit den <em>Datentyp</em> einer Variable, eines Funktionsparameters oder eines R√ºckgabewerts angibst. Das hilft TypeScript, Fehler fr√ºhzeitig zu erkennen und deinen Code sicherer und leichter verst√§ndlich zu machen.</p>

  <h3>1. Type Annotation f√ºr Variablen</h3>
  <p>Du kannst einer Variablen direkt einen Typ zuweisen:</p>
  <pre><code>let name: string = "Anna";
const alter: number = 30;
let istAktiv: boolean = true;
</code></pre>
  <p><em>: string</em> sagt: Die Variable <code>name</code> darf nur Strings speichern.<br>
     <em>: number</em> nur Zahlen.<br>
     <em>: boolean</em> nur Wahrheitswerte (<code>true</code> oder <code>false</code>).</p>

  <h3>2. Type Annotation f√ºr Funktionsparameter</h3>
  <p>Wenn du eine Funktion schreibst, kannst du f√ºr jeden Parameter den Typ angeben:</p>
  <pre><code>function begruessung(name: string) {
  console.log("Hallo, " + name);
}
</code></pre>
  <p>Hier gilt: <code>name</code> muss ein String sein, sonst gibt TypeScript einen Fehler.</p>

  <h3>3. Type Annotation f√ºr R√ºckgabewerte</h3>
  <p>Du kannst auch angeben, welchen Typ eine Funktion zur√ºckgibt, indem du den Typ <strong>nach den Parametern</strong> mit <code>:</code> definierst:</p>
  <pre><code>function addiere(a: number, b: number): number {
  return a + b;
}
</code></pre>
  <p>Die Funktion <code>addiere</code> nimmt zwei <code>number</code>-Parameter und gibt eine <code>number</code> zur√ºck.</p>

  <h3>4. Komplettes Beispiel</h3>
  <pre><code>function multipliziere(x: number, y: number): number {
  return x * y;
}

let ergebnis: number = multipliziere(5, 3);
console.log(ergebnis);  // 15
</code></pre>

  <h3>Warum ist das so sch√∂n?</h3>
  <ul>
    <li><strong>Sicherheit:</strong> TypeScript warnt dich, wenn du versehentlich falsche Typen benutzt.</li>
    <li><strong>Lesbarkeit:</strong> Andere (und dein zuk√ºnftiges Ich) verstehen sofort, was erwartet wird.</li>
    <li><strong>Autovervollst√§ndigung:</strong> Editor-Tools helfen dir besser mit Typinfos.</li>
  </ul>

  <p>Das ist besonders n√ºtzlich in gro√üen Projekten, wo viele Entwickler zusammenarbeiten.</p>
<h3>Hier ist ein einfaches Beispiel:</h3>
<pre><code>let zahl: number = 5;          // Variable vom Typ number
function addiere(a: number, b: number): number { // Parameter und R√ºckgabewert typisiert
  return a + b;
}
</code></pre>

<h2>5. Wie beschreibe ich Arrays in TypeScript?</h2>
 <h2>5. Wie beschreibe ich Arrays in TypeScript?</h2>
  <p>In TypeScript kannst du den Typ der Elemente in einem Array genau angeben. So wei√ü der Compiler, was drin steckt und sch√ºtzt dich vor Fehlern.</p>

  <h3>1. Einfache Arrays mit Typ Annotation</h3>
  <pre><code>let zahlen: number[] = [1, 2, 3, 4];
let namen: string[] = ["Anna", "Ben", "Clara"];
let aktivStatus: boolean[] = [true, false, true];</code></pre>
  <ul>
    <li><code>number[]</code> hei√üt: Ein Array aus Zahlen.</li>
    <li><code>string[]</code> hei√üt: Ein Array aus Strings.</li>
    <li><code>boolean[]</code> hei√üt: Ein Array aus Wahrheitswerten.</li>
  </ul>

  <h3>2. Alternative Schreibweise mit generischen Typen</h3>
  <p>TypeScript erlaubt auch eine andere Syntax mit <code>Array&lt;T&gt;</code>:</p>
  <pre><code>let zahlen: Array &lt;number&gt; = [1, 2, 3, 4];
let namen: Array &lt;string&gt; = ["Anna", "Ben", "Clara"];</code></pre>
<p class="note">bedeutet gleich so Viel wie:</p>
<pre><code>let zahlen: number[] = [1, 2, 3];
let namen: Array&lt;string&gt; = ["Anna", "Bob"];
</code></pre>
  <p>Beide Varianten sind gleich g√ºltig, du kannst also w√§hlen, was dir besser gef√§llt.</p>

  <h3>3. Arrays mit mehreren Typen (Union Types)</h3>
  <p>Manchmal m√∂chtest du, dass ein Array verschiedene Typen enthalten darf, z.B. Zahlen und Strings gemischt:</p>
  <pre><code>let gemischt: (number | string)[] = [1, "zwei", 3, "vier"];</code></pre>
  <p>Hier hei√üt <code>(number | string)[]</code>: Das Array kann Zahlen <strong>oder</strong> Strings enthalten.</p>

  <h3>4. Mehrdimensionale Arrays</h3>
  <p>Du kannst auch Arrays von Arrays (Matrix) typisieren:</p>
  <pre><code>let matrix: number[][] = [
  [1, 2],
  [3, 4]
];</code></pre>
  <p>Das hei√üt: Ein Array von Arrays, wobei jedes innere Array Zahlen enth√§lt.</p>

  <h3>5. Beispiel in einer Funktion</h3>
  <pre><code>function summiere(zahlen: number[]): number {
  return zahlen.reduce((acc, curr) => acc + curr, 0);
}

let ergebnis = summiere([10, 20, 30]);
console.log(ergebnis);  // 60</code></pre>

  <h3>Warum ist das praktisch?</h3>
  <ul>
    <li>Du vermeidest Fehler durch falsche Datentypen im Array.</li>
    <li>Dein Code ist klarer und leichter verst√§ndlich.</li>
    <li>Intellisense und Autovervollst√§ndigung im Editor helfen dir.</li>
  </ul>




<h2>6. Wie beschreibe ich Objekte in TypeScript?</h2>
<p>In TypeScript kannst du genau definieren, welche Eigenschaften ein Objekt hat und welchen Typ diese Eigenschaften besitzen. Das hilft dir, Fehler zu vermeiden und deinen Code klarer zu machen.</p>

<h3>1. Objekt-Typ mit Inline-Typannotation</h3>
<p>Du kannst direkt beim Objekt angeben, welche Eigenschaften und Typen es haben soll:</p>
<pre><code>let person: { name: string; alter: number; istStudent: boolean } = {
  name: "Max",
  alter: 25,
  istStudent: true,
};</code></pre>
<ul>
  <li><code>name</code> ist ein String</li>
  <li><code>alter</code> ist eine Zahl</li>
  <li><code>istStudent</code> ist ein Wahrheitswert (Boolean)</li>
</ul>

<h3>2. Objekttyp mit <code>type</code> Alias</h3>
<p>Wenn du denselben Objekttyp √∂fter brauchst, kannst du ihn mit <code>type</code> einmal definieren und dann verwenden:</p>
<pre><code>type Person = {
  name: string;
  alter: number;
  istStudent: boolean;
};

let person1: Person = {
  name: "Anna",
  alter: 22,
  istStudent: false,
};

let person2: Person = {
  name: "Ben",
  alter: 30,
  istStudent: true,
};</code></pre>

<h3>3. Optional Properties (Optionale Eigenschaften)</h3>
<p>Manchmal sind manche Eigenschaften nicht immer vorhanden. Das kannst du mit <code>?</code> markieren:</p>
<pre><code>type Auto = {
  marke: string;
  baujahr?: number;  // optional
};

let auto1: Auto = { marke: "VW" };
let auto2: Auto = { marke: "BMW", baujahr: 2018 };</code></pre>

<h3>4. Objekt mit Methoden (Funktionen als Eigenschaften)</h3>
<p>Objekte k√∂nnen auch Funktionen als Eigenschaften haben, diese kannst du ebenfalls typisieren:</p>
<pre><code>type Rechner = {
  addiere: (a: number, b: number) => number;
};

let rechner: Rechner = {
  addiere: (x, y) => x + y,
};

console.log(rechner.addiere(5, 3));  // 8</code></pre>

<h3>5. Verschachtelte Objekte (Nested Objects)</h3>
<p>Objekte k√∂nnen auch andere Objekte als Eigenschaften enthalten:</p>
<pre><code>type Adresse = {
  strasse: string;
  stadt: string;
};

type Mitarbeiter = {
  name: string;
  adresse: Adresse;
};

let mitarbeiter: Mitarbeiter = {
  name: "Lisa",
  adresse: {
    strasse: "Hauptstr. 5",
    stadt: "Berlin",
  },
};</code></pre>

<h3>Warum ist das praktisch?</h3>
<ul>
  <li>Du hast eine klare Struktur und Beschreibung deiner Daten.</li>
  <li>Fehler wie falsche Eigenschaftsnamen oder falsche Typen werden fr√ºh erkannt.</li>
  <li>Dein Code ist besser wartbar und leichter verst√§ndlich.</li>
  <li>Die Entwicklungsumgebung kann dir besser mit Autovervollst√§ndigung helfen.</li>
</ul>


<h2>7. Wie verwende ich Interfaces in TypeScript?</h2>

<p>In TypeScript sind <strong>Interfaces</strong> eines der wichtigsten Werkzeuge, um die Struktur von Objekten, Klassen oder Funktionen zu definieren. Sie sind besonders n√ºtzlich, um klare Vertr√§ge (Contracts) zwischen verschiedenen Teilen deines Codes zu schaffen und helfen dabei, Fehler fr√ºhzeitig zu erkennen. Hier bekommst du eine <strong>richtig professorenreife, detaillierte Erkl√§rung</strong> mit verst√§ndlichen Beispielen.</p>

<h3>1. Was ist ein Interface?</h3>

<p>Ein Interface beschreibt die Form eines Objekts: welche Eigenschaften und Methoden es haben muss und welchen Typ diese besitzen. Es ist also wie eine Vorlage, die Objekte erf√ºllen m√ºssen.</p>

<pre><code>interface Person {
  name: string;
  alter: number;
}

let user: Person = {
  name: "Lisa",
  alter: 25
};
</code></pre>

<p>Jedes Objekt, das dem Interface <code>Person</code> entspricht, muss diese Eigenschaften haben.</p>

<h3>2. Interface benutzen</h3>

<p>Du kannst Interfaces direkt als Typ f√ºr Variablen, Funktionsparameter oder R√ºckgabewerte verwenden:</p>

<pre><code>function begr√º√üe(person: Person): string {
  return `Hallo, ${person.name}! Du bist ${person.alter} Jahre alt.`;
}

const max: Person = {
  name: "Max",
  alter: 25,
};

console.log(begr√º√üe(max)); // Hallo, Max! Du bist 25 Jahre alt.
</code></pre>

<h3>3. Optionale Eigenschaften</h3>

<p>Manchmal hat nicht jedes Objekt alle Eigenschaften. Das kannst du mit <code>?</code> kennzeichnen:</p>

<pre><code>interface Auto {
  marke: string;
  baujahr?: number; // optional
}

const meinAuto: Auto = { marke: "VW" };
const altesAuto: Auto = { marke: "Opel", baujahr: 1998 };
</code></pre>

<h3>4. Methoden in Interfaces</h3>

<p>Interfaces k√∂nnen auch Methoden beschreiben, also Funktionen, die ein Objekt haben muss:</p>

<pre><code>interface Rechner {
  addiere(a: number, b: number): number;
  subtrahiere(a: number, b: number): number;
}

const einfacherRechner: Rechner = {
  addiere: (x, y) => x + y,
  subtrahiere: (x, y) => x - y,
};

console.log(einfacherRechner.addiere(5, 3)); // 8
console.log(einfacherRechner.subtrahiere(5, 3)); // 2
</code></pre>

<h3>5. Interface-Vererbung (extends)</h3>

<p>Interfaces k√∂nnen von anderen Interfaces erben und deren Eigenschaften √ºbernehmen. So kannst du komplexere Strukturen modular aufbauen:</p>

<pre><code>interface Lebewesen {
  lebt: boolean;
}

interface Mensch extends Lebewesen {
  name: string;
  sprache: string;
}

const person: Mensch = {
  lebt: true,
  name: "Anna",
  sprache: "Deutsch",
};
</code></pre>

<h3>6. Unterschied zu <code>type</code> Alias</h3>

<ul>
  <li><code>interface</code> eignet sich speziell f√ºr Objekte und unterst√ºtzt Vererbung und Deklarationserweiterung (Merging).</li>
  <li><code>type</code> ist allgemeiner und kann auch f√ºr Unionen, Tupel, primitive Typen etc. verwendet werden.</li>
  <li>Interfaces k√∂nnen mehrfach deklariert werden und TypeScript verbindet sie automatisch (Declaration Merging), <code>type</code>-Aliases nicht.</li>
</ul>

<h3>7. Praktische Vorteile von Interfaces</h3>

<ul>
  <li><strong>Klarheit &amp; Struktur:</strong> Dein Code wird lesbarer und verst√§ndlicher.</li>
  <li><strong>Fr√ºherkennung von Fehlern:</strong> TypeScript pr√ºft, ob Objekte die vorgegebene Struktur erf√ºllen.</li>
  <li><strong>Autovervollst√§ndigung:</strong> Editoren wie VSCode unterst√ºtzen dich mit intelligenten Vorschl√§gen.</li>
  <li><strong>Flexibilit√§t:</strong> Mit optionalen Feldern und Vererbung kannst du deinen Code sauber und wartbar halten.</li>
</ul>

<h3>8. Beispiel in der Praxis</h3>

<pre><code>interface Produkt {
  id: number;
  name: string;
  preis: number;
  beschreibung?: string;
}

function zeigeProdukt(produkt: Produkt) {
  console.log(`${produkt.name} kostet ${produkt.preis} Euro.`);
  if (produkt.beschreibung) {
    console.log(`Beschreibung: ${produkt.beschreibung}`);
  }
}

const buch: Produkt = { id: 1, name: "TypeScript f√ºr Einsteiger", preis: 29.99 };
zeigeProdukt(buch);
</code></pre>

<h3>Fazit</h3>

<p>Interfaces sind ein kraftvolles Tool, um in TypeScript <strong>sauberen, gut strukturierten und wartbaren Code</strong> zu schreiben. Sie helfen dir, Datenformen klar zu definieren und erleichtern Zusammenarbeit und Erweiterbarkeit deines Codes erheblich.</p>


<h2>8. Wie verwende ich Type in TypeScript?</h2>

<p>In TypeScript ist <code>type</code> ein m√§chtiges Werkzeug, um eigene Typen zu definieren. Es hilft dir, komplexe Strukturen einfach zu benennen und wiederzuverwenden. Im Gegensatz zu Interfaces kann <code>type</code> viel flexibler sein, weil es nicht nur Objekte, sondern auch Union-Types, Tuples oder primitive Typen zusammenfassen kann.</p>

<h3>1. Grundlegende Verwendung von <code>type</code> mit Objekten</h3>

<pre><code>type Person = {
  name: string;
  alter: number;
  istStudent: boolean;
};

let user: Person = {
  name: "Anna",
  alter: 23,
  istStudent: true,
};
</code></pre>

<p><strong>Erkl√§rung:</strong></p>
<ul>
  <li>Du definierst mit <code>type Person = &#123; ... &#125;</code> eine neue Typ-Schablone.</li>
  <li>Diese Schablone legt fest, welche Eigenschaften und Typen ein Objekt haben soll.</li>
  <li>Danach kannst du √ºberall im Code den Typ <code>Person</code> verwenden.</li>
  <li>Das macht deinen Code lesbarer und wiederverwendbar.</li>
</ul>

<h3>2. <code>type</code> mit primitiven Typen und Aliasen</h3>

<pre><code>type ID = string | number;

let userId: ID = "abc123";
userId = 456; // auch erlaubt
</code></pre>

<p><strong>Erkl√§rung:</strong></p>
<ul>
  <li><code>type</code> kann auch sogenannte Union Types definieren.</li>
  <li><code>ID</code> ist hier ein Typ, der entweder ein <code>string</code> oder eine <code>number</code> sein kann.</li>
  <li>So kannst du flexibel mit verschiedenen Typen arbeiten, ohne √ºberall Union-Typen ausschreiben zu m√ºssen.</li>
</ul>

<h3>3. Union-Types mit <code>type</code></h3>

<pre><code>type Status = "aktiv" | "inaktiv" | "gesperrt";

let userStatus: Status = "aktiv";
// userStatus = "pausiert"; // Fehler, weil nicht definiert
</code></pre>

<p><strong>Erkl√§rung:</strong></p>
<ul>
  <li>Du kannst mit <code>type</code> auch Literaltypen angeben, also ganz genaue Werte, die erlaubt sind.</li>
  <li>So kann <code>userStatus</code> nur eine von drei vordefinierten Zeichenketten sein.</li>
  <li>Das hilft Fehler zu vermeiden und macht deinen Code sicherer.</li>
</ul>

<h3>4. Kombinieren von Typen mit Intersection (&amp;)</h3>

<pre><code>type Basis = &#123;
  id: number;
&#125;;

type Erweiterung = &#123;
  name: string;
&#125;;

type Komplett = Basis &amp; Erweiterung;

const obj: Komplett = &#123;
  id: 1,
  name: "Test",
&#125;;
</code></pre>

<p><strong>Erkl√§rung:</strong></p>
<ul>
  <li>Intersection Types verbinden mehrere Typen zu einem.</li>
  <li><code>Komplett</code> muss also alle Eigenschaften von <code>Basis</code> UND <code>Erweiterung</code> haben.</li>
  <li>So kannst du Typen modular aufbauen.</li>
</ul>

<h3>5. Tuple mit <code>type</code></h3>

<pre><code>type Koordinate = [number, number];

let punkt: Koordinate = [10, 20];
</code></pre>

<p><strong>Erkl√§rung:</strong></p>
<ul>
  <li>Mit <code>type</code> kannst du auch Tupel definieren, also Arrays mit festgelegter L√§nge und Typen.</li>
  <li><code>Koordinate</code> ist ein Array mit genau zwei Zahlen.</li>
  <li>So sind Fehler z.B. bei Koordinaten-Daten ausgeschlossen.</li>
</ul>

<h3>Warum <code>type</code> verwenden?</h3>
<ul>
  <li><strong>Flexibel:</strong> Du kannst primitive Typen, Objekte, Union-Types, Intersection-Types und Tupel definieren.</li>
  <li><strong>Wiederverwendbar:</strong> Du gibst komplexen Strukturen einen Namen und sparst dir st√§ndige Wiederholung.</li>
  <li><strong>Sicher:</strong> Typfehler werden vom Compiler fr√ºh erkannt.</li>
  <li><strong>Lesbar:</strong> Der Code wird klarer, weil Typen einen aussagekr√§ftigen Namen haben.</li>
</ul>

<h3>Zusammenfassung:</h3>

<p>Mit <code>type</code> definierst du eigene Typen und Typ-Alias, die dein TypeScript-Code sicherer, verst√§ndlicher und wartbarer machen. Du kannst damit einfache und komplexe Typen flexibel beschreiben.</p>


<h2>9. Was ist der Unterschied zwischen <code>interface</code> und <code>type</code> in TypeScript?</h2>
<table>
  <thead>
    <tr>
      <th>Interface</th>
      <th>Type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Wird meist f√ºr Objektformen verwendet</td>
      <td>Kann auch primitive Typen, Unions, Tupel usw. beschreiben</td>
    </tr>
    <tr>
      <td>Kann erweitert (extends) werden</td>
      <td>Kann mit anderen Types kombiniert werden (Intersection)</td>
    </tr>
    <tr>
      <td>Kann mehrfach deklariert werden (zusammengef√ºhrt)</td>
      <td>Kann nicht mehrfach mit gleichem Namen deklariert werden</td>
    </tr>
  </tbody>
</table>

<h2></h2>

<p>In TypeScript nutzt man <code>interface</code> und <code>type</code>, um eigene Typdefinitionen zu erstellen. Beide erf√ºllen √§hnliche Aufgaben, doch sie unterscheiden sich in bestimmten Punkten, besonders bei Flexibilit√§t, Erweiterbarkeit und Verhalten im Code.</p>

<h3>1. Objektbeschreibung mit beiden</h3>

<p>Beide Varianten k√∂nnen genutzt werden, um Objektstrukturen zu definieren:</p>

<pre><code>// Interface
interface Person {
  name: string;
  alter: number;
}

// Type
type Person = {
  name: string;
  alter: number;
};
</code></pre>

<p>F√ºr einfache Objekte sind beide gleichwertig einsetzbar.</p>

<h3>2. Union Types, Funktionen, Tupel (nur mit <code>type</code>)</h3>

<p><code>type</code> ist flexibler bei der Kombination mehrerer Typen, zum Beispiel:</p>

<pre><code>type ID = string | number;
type Position = [number, number];
type Rechner = (a: number, b: number) => number;
</code></pre>

<p>Diese Dinge sind mit <code>interface</code> nicht m√∂glich.</p>

<h3>3. Erweiterung / Vererbung</h3>

<p>Beide unterst√ºtzen Erweiterung, jedoch in unterschiedlicher Syntax:</p>

<pre><code>// Interface mit extends
interface Tier {
  name: string;
}
interface Hund extends Tier {
  bellt: boolean;
}

// Type mit Intersection
type Tier = { name: string };
type Hund = Tier & { bellt: boolean };
</code></pre>

<p>Interfaces wirken hier oft lesbarer, besonders bei komplexeren Strukturen.</p>

<h3>4. Mehrfachdefinition (nur mit <code>interface</code>)</h3>

<p>Ein gro√üer Vorteil von <code>interface</code> ist das sogenannte Declaration Merging:</p>

<pre><code>interface Nutzer {
  name: string;
}
interface Nutzer {
  alter: number;
}
// Ergibt: { name: string; alter: number }
</code></pre>

<p>Das geht mit <code>type</code> nicht ‚Äì doppelte Definition f√ºhrt zu einem Fehler.</p>

<h3>5. Einsatz in Klassen</h3>

<p>Interfaces sind speziell daf√ºr entworfen, Klassentypen zu beschreiben. Sie passen gut in objektorientierte Strukturen:</p>

<pre><code>interface Tier {
  name: string;
}

class Hund implements Tier {
  name = "Bello";
}
</code></pre>

<p>Mit <code>type</code> ist das nicht direkt m√∂glich.</p>

<h3>Zusammenfassung und Entscheidungshilfe</h3>

<table border="1" cellpadding="6" cellspacing="0">
  <thead>
    <tr>
      <th>Eigenschaft</th>
      <th>interface ‚úÖ</th>
      <th>type ‚úÖ</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Objektbeschreibung</td>
      <td>‚úÖ Ja</td>
      <td>‚úÖ Ja</td>
    </tr>
    <tr>
      <td>Union Types</td>
      <td>‚ùå Nein</td>
      <td>‚úÖ Ja</td>
    </tr>
    <tr>
      <td>Funktionen / Tupel</td>
      <td>‚ùå Nein</td>
      <td>‚úÖ Ja</td>
    </tr>
    <tr>
      <td>Erweiterung (Vererbung)</td>
      <td>‚úÖ mit <code>extends</code></td>
      <td>‚úÖ mit <code>&</code></td>
    </tr>
    <tr>
      <td>Mehrfachdefinition m√∂glich</td>
      <td>‚úÖ Ja (Merging)</td>
      <td>‚ùå Nein (Fehler)</td>
    </tr>
    <tr>
      <td>Verwendung f√ºr Klassen</td>
      <td>‚úÖ Ideal</td>
      <td>‚ùå Geht nicht direkt</td>
    </tr>
  </tbody>
</table>

<div>
  <h4>üëâ Nimm das, welches logischer ist:</h4>
  <ul>
    <li>Willst du ein <strong>klar strukturiertes Objektmodell</strong> oder arbeitest mit Klassen ‚Üí <code>interface</code></li>
    <li>Willst du <strong>Typen flexibel kombinieren</strong> (Unions, Funktionen, Tupel) ‚Üí <code>type</code></li>
  </ul>
</div>

<h4>Merksatz:</h4>
<p><code>interface</code> = Struktur<br>
<code>type</code> = Vielseitigkeit</p>

<p>Beides sind m√§chtige Werkzeuge ‚Äì die Wahl h√§ngt vom Anwendungsfall ab.</p>

<h2>10. Wie verwende ich Union Types?</h2>


<h3>üß† Was sind Union Types?</h3>
<p>Union Types in TypeScript erlauben dir, <strong>mehrere m√∂gliche Typen f√ºr eine Variable oder Funktion</strong> zu definieren. Das bedeutet, dass eine Variable entweder vom Typ A <strong>oder</strong> vom Typ B sein darf.</p>

<h3>üìò Syntax</h3>
<pre><code>let variable: string | number;
</code></pre>
<p><strong>Das bedeutet:</strong> <code>variable</code> kann <strong>entweder ein string oder eine number</strong> sein.</p>

<h3>üéì Beispiel 1: Einfache Union</h3>
<pre><code>let benutzerId: string | number;

benutzerId = "abc123";
benutzerId = 456;
</code></pre>
<p>‚úÖ <strong>G√ºltig</strong>, weil <code>benutzerId</code> entweder ein <code>string</code> oder <code>number</code> sein darf.</p>

<pre><code>benutzerId = true; // ‚ùå Error: boolean ist nicht erlaubt
</code></pre>

<h3>üéì Beispiel 2: Funktion mit Union-Typ</h3>
<pre><code>function druckeId(id: string | number): void {
  console.log("Die ID ist:", id);
}

druckeId("A45Z");
druckeId(1024);
</code></pre>

<h3>üéì Beispiel 3: Union mit Arrays</h3>
<pre><code>let daten: (string | number)[] = [1, "zwei", 3, "vier"];
</code></pre>
<p><strong>Hinweis:</strong> Die Klammern nach dem Union <code>(string | number)[]</code> bedeuten: ‚ÄûEin Array, dessen Elemente entweder <code>string</code> oder <code>number</code> sein d√ºrfen.‚Äú</p>

<h3>üéì Beispiel 4: Union mit Typ-Alias</h3>
<pre><code>type ID = string | number;

let userId: ID = "user-001";
userId = 999;
</code></pre>
<p>‚úÖ So kannst du den Union-Typ <strong>wiederverwenden</strong>.</p>

<h3>üö´ Was geht nicht mit Union?</h3>
<pre><code>let mixed: string | number = "test";

console.log(mixed.toUpperCase()); // ‚ùå Fehler!
</code></pre>
<p><strong>Warum?</strong> TypeScript wei√ü <strong>nicht</strong>, ob <code>mixed</code> ein <code>string</code> oder <code>number</code> ist ‚Üí Du musst erst pr√ºfen:</p>

<pre><code>if (typeof mixed === "string") {
  console.log(mixed.toUpperCase()); // ‚úÖ
}
</code></pre>

<h3>üîé Vorteile von Union Types</h3>
<ul>
  <li>‚úÖ Erlaubt dir <strong>flexible Eingaben</strong></li>
  <li>‚úÖ Gut f√ºr APIs, die verschiedene Formate zur√ºckgeben</li>
  <li>‚úÖ St√§rkt die <strong>Typensicherheit</strong> durch explizite Typangabe</li>
  <li>‚úÖ In Kombination mit <code>type</code> und <code>interface</code> sehr m√§chtig</li>
</ul>

<h3>üßæ Zusammenfassung</h3>
<table border="1" cellpadding="6" cellspacing="0">
  <thead>
    <tr>
      <th>Was?</th>
      <th>Beispiel</th>
      <th>Erkl√§rung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Union-Typ</td>
      <td><code>string | number</code></td>
      <td>Mehrere Typen erlaubt</td>
    </tr>
    <tr>
      <td>Array mit Union-Typ</td>
      <td><code>(string | number)[]</code></td>
      <td>Elemente d√ºrfen gemischt sein</td>
    </tr>
    <tr>
      <td>Funktion mit Union</td>
      <td><code>function(id: string | number)</code></td>
      <td>Argument kann mehrere Typen annehmen</td>
    </tr>
    <tr>
      <td>Mit <code>type</code> alias</td>
      <td><code>type ID = string | number;</code></td>
      <td>F√ºr Wiederverwendung</td>
    </tr>
    <tr>
      <td>Vorsicht bei Zugriff</td>
      <td><code>typeof</code> verwenden</td>
      <td>Sonst k√∂nnte es zu Fehlern f√ºhren</td>
    </tr>
  </tbody>
</table>


<h2>11. Wie verwende ich Intersection Types?</h2>

<p>Intersection Types in TypeScript kombinieren mehrere Typen zu einem neuen Typ, der <strong>alle Eigenschaften und Anforderungen</strong> der beteiligten Typen erf√ºllt. Das bedeutet: Ein Wert vom Intersection Type muss alle Eigenschaften aller zusammengef√ºhrten Typen besitzen.</p>

<h3>Syntax</h3>
<pre><code>type TypA = { a: number };
type TypB = { b: string };

type Schnittmenge = TypA &amp; TypB;
</code></pre>
<p><code>Schnittmenge</code> hat hier sowohl die Eigenschaft <code>a</code> (Zahl) als auch <code>b</code> (String).</p>

<h3>Beispiel 1: Kombination von Objekttypen</h3>
<pre><code>type Person = { name: string };
type Angestellter = { mitarbeiterId: number };

type Mitarbeiter = Person &amp; Angestellter;

let p: Mitarbeiter = {
  name: "Anna",
  mitarbeiterId: 123,
};
</code></pre>
<ul>
  <li><code>Mitarbeiter</code> ist ein Typ, der beide Eigenschaften von <code>Person</code> und <code>Angestellter</code> enth√§lt.</li>
  <li>Eine Variable vom Typ <code>Mitarbeiter</code> muss sowohl <code>name</code> als auch <code>mitarbeiterId</code> besitzen.</li>
  <li>Fehlt eine Eigenschaft, meldet TypeScript einen Fehler.</li>
</ul>

<h3>Beispiel 2: Intersection mit Funktionen</h3>
<pre><code>type Logger = { log: (msg: string) =&gt; void };
type FehlerLogger = { logError: (err: Error) =&gt; void };

type VollstaendigerLogger = Logger &amp; FehlerLogger;

let logger: VollstaendigerLogger = {
  log: (msg) =&gt; console.log("Info:", msg),
  logError: (err) =&gt; console.error("Error:", err.message),
};
</code></pre>
<ul>
  <li><code>VollstaendigerLogger</code> muss beide Funktionen <code>log</code> und <code>logError</code> besitzen.</li>
  <li>So kannst du unterschiedliche F√§higkeiten kombinieren und trotzdem typensicher bleiben.</li>
</ul>

<h3>Beispiel 3: Intersection mit Interface und Type</h3>
<pre><code>interface Fahrzeug {
  fahren(): void;
}

type Motorisiert = {
  motor: boolean;
};

type Auto = Fahrzeug &amp; Motorisiert;

const meinAuto: Auto = {
  motor: true,
  fahren() {
    console.log("Das Auto f√§hrt.");
  },
};
</code></pre>
<ul>
  <li>Kombination von Interface und Typ.</li>
  <li><code>Auto</code> muss alle Eigenschaften und Methoden beider Typen haben.</li>
</ul>

<h3>Wann nutzt man Intersection Types?</h3>
<ul>
  <li>Um komplexe Typen aus mehreren einfacheren zusammenzustellen.</li>
  <li>Wenn ein Objekt mehrere Rollen oder F√§higkeiten haben soll.</li>
  <li>F√ºr flexible und dennoch sichere Typdefinitionen.</li>
</ul>

<h3>Wichtig zu wissen</h3>
<ul>
  <li>Intersection Types erfordern, dass alle Typen gleichzeitig erf√ºllt sind.</li>
  <li>Unvereinbare Typen (z.B. <code>string &amp; number</code>) sind nicht m√∂glich.</li>
  <li>Gut f√ºr Mixin-Muster oder das Kombinieren von Eigenschaften.</li>
</ul>

<h3>Kurze Tabelle zur √úbersicht</h3>
<table border="1" cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Eigenschaft</th>
      <th>Beschreibung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Typenkombination</td>
      <td>Vereint mehrere Typen zu einem (mit <code>&amp;</code>)</td>
    </tr>
    <tr>
      <td>Ergebnis</td>
      <td>Neuer Typ mit allen Eigenschaften der beteiligten Typen</td>
    </tr>
    <tr>
      <td>Verwendung</td>
      <td>F√ºr Objekte, die mehrere Rollen/F√§higkeiten besitzen</td>
    </tr>
    <tr>
      <td>Einschr√§nkungen</td>
      <td>Keine unvereinbaren Typen m√∂glich</td>
    </tr>
  </tbody>
</table>

<h3>Fazit</h3>
<p>Intersection Types sind ein m√§chtiges Werkzeug in TypeScript, um Typen sicher und modular zu kombinieren. Sie sorgen daf√ºr, dass dein Code klar bleibt und alle notwendigen Eigenschaften in einem Typ zusammengefasst sind.</p>


<h2>12. Was sind Generics? Wie verwende ich sie?</h2>

<p>Generics sind Platzhalter f√ºr Typen. Damit kannst du Funktionen, Klassen oder Interfaces schreiben, die nicht auf einen bestimmten Typ festgelegt sind, sondern mit verschiedenen Typen flexibel arbeiten k√∂nnen. Das macht deinen Code wiederverwendbar und trotzdem typensicher.</p>

<h3>Syntax</h3>
<pre><code>function identitaet&lt;T&gt;(wert: T): T {
  return wert;
}
</code></pre>
<ul>
  <li><code>&lt;T&gt;</code> ist der Typ-Parameter. Er steht f√ºr einen beliebigen Typ.</li>
  <li><code>wert: T</code> bedeutet: Die Funktion nimmt einen Wert vom Typ <code>T</code>.</li>
  <li><code>: T</code> sagt, die Funktion gibt genau denselben Typ zur√ºck.</li>
  <li>Du kannst beim Aufruf z.B. <code>identitaet&lt;string&gt;("Hallo")</code> schreiben oder TypeScript den Typ automatisch ableiten lassen: <code>identitaet(123)</code>.</li>
</ul>

<h3>Beispiel 1: Generische Funktion</h3>
<pre><code>function wrapInArray&lt;T&gt;(element: T): T[] {
  return [element];
}

const zahlen = wrapInArray&lt;number&gt;(5);      // [5]
const namen = wrapInArray("Anna");               // ["Anna"], Typ wird automatisch erkannt
</code></pre>

<h3>Beispiel 2: Generisches Interface</h3>
<pre><code>interface Result&lt;T&gt; {
  data: T;
  error?: string;
}

const ergebnis: Result&lt;string&gt; = {
  data: "Erfolg",
};

const fehlerErgebnis: Result&lt;number&gt; = {
  data: 0,
  error: "Kein Wert gefunden",
};
</code></pre>

<h3>Beispiel 3: Generische Klasse</h3>
<pre><code>class Speicher&lt;T&gt; {
  private wert: T;

  constructor(wert: T) {
    this.wert = wert;
  }

  holeWert(): T {
    return this.wert;
  }
}

const speicher = new Speicher&lt;string&gt;("Hallo");
console.log(speicher.holeWert());  // "Hallo"
</code></pre>

<h3>Warum Generics benutzen?</h3>
<ul>
  <li>Vermeidet duplizierten Code f√ºr verschiedene Typen.</li>
  <li>Bietet Typsicherheit f√ºr flexible, wiederverwendbare Komponenten.</li>
  <li>Hilft dem Compiler, Typfehler fr√ºh zu erkennen.</li>
  <li>Macht deinen Code leichter verst√§ndlich und wartbar.</li>
</ul>

<h3>Zusammenfassung in Tabelle</h3>
<table border="1" cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Eigenschaft</th>
      <th>Beschreibung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Zweck</td>
      <td>Platzhalter f√ºr Typen, flexibel &amp; wiederverwendbar</td>
    </tr>
    <tr>
      <td>Syntax</td>
      <td><code>&lt;T&gt;</code>, <code>&lt;U&gt;</code>, etc. als Typ-Parameter</td>
    </tr>
    <tr>
      <td>Verwendung</td>
      <td>Funktionen, Klassen, Interfaces</td>
    </tr>
    <tr>
      <td>Vorteil</td>
      <td>Typsicherheit + Flexibilit√§t</td>
    </tr>
    <tr>
      <td>Beispiel</td>
      <td><code>function f&lt;T&gt;(x: T): T</code></td>
    </tr>
  </tbody>
</table>



<h2>13. Was sind Enums in TypeScript? Wie verwende ich sie?</h2>


<p>Enums in TypeScript sind eine spezielle Art, um eine Gruppe von benannten Konstanten zusammenzufassen. Sie helfen dir dabei, Code lesbarer und besser wartbar zu machen, indem du klare Namen f√ºr feste Werte benutzt, anstatt "magische Zahlen" oder Strings mehrfach zu schreiben.</p>

<h3>Was sind Enums?</h3>
<ul>
  <li>Enums (kurz f√ºr Enumerations) sind Datentypen, die eine Menge von benannten Werten definieren.</li>
  <li>Jeder Wert in einem Enum hat einen Namen und einen zugeh√∂rigen Wert (standardm√§√üig Zahlen beginnend bei 0).</li>
  <li>Du kannst sowohl numerische als auch stringbasierte Enums erstellen.</li>
</ul>

<h3>Syntax &amp; Beispiele</h3>

<h4>Numerische Enums (Standard)</h4>
<pre><code>enum Status {
  Neu,            // 0
  InBearbeitung,  // 1
  Fertig          // 2
}

let aktuellerStatus: Status = Status.InBearbeitung;
console.log(aktuellerStatus);  // Ausgabe: 1
</code></pre>
<p><strong>Erkl√§rung:</strong><br>
- <code>Status</code> ist der Enum-Name.<br>
- Die Werte fangen standardm√§√üig bei 0 an und erh√∂hen sich automatisch.<br>
- <code>Status.InBearbeitung</code> ist also eigentlich der Wert <code>1</code>.</p>

<h4>String Enums</h4>
<pre><code>enum Farben {
  Rot = "ROT",
  Gruen = "GRUEN",
  Blau = "BLAU"
}

let farbe: Farben = Farben.Rot;
console.log(farbe);  // Ausgabe: "ROT"
</code></pre>
<p><strong>Erkl√§rung:</strong><br>
- Statt Zahlen kannst du jedem Enum-Wert auch einen String zuweisen.<br>
- Das macht den Code oft klarer, vor allem wenn die Werte repr√§sentativ sein sollen.</p>

<h3>Warum Enums verwenden?</h3>
<ul>
  <li>Mehr Lesbarkeit und Verst√§ndlichkeit statt Zahlen oder Strings direkt im Code.</li>
  <li>Verhindert Tippfehler, weil man nur die definierten Enum-Namen nutzen kann.</li>
  <li>Intellisense in Editoren gibt dir Vorschl√§ge und zeigt m√∂gliche Werte an.</li>
  <li>Einfaches Mapping zwischen Namen und Werten.</li>
</ul>

<h3>Beispiel mit Funktion</h3>
<pre><code>enum Status {
  Offen,
  Geschlossen,
  InBearbeitung
}

function statusCheck(status: Status): string {
  if (status === Status.Offen) {
    return "Der Auftrag ist offen.";
  } else if (status === Status.Geschlossen) {
    return "Der Auftrag ist geschlossen.";
  } else {
    return "Der Auftrag wird bearbeitet.";
  }
}

console.log(statusCheck(Status.Geschlossen));  // "Der Auftrag ist geschlossen."
</code></pre>
<p><strong>Erkl√§rung:</strong><br>
- Die Funktion nimmt als Parameter einen Wert vom Enum-Typ <code>Status</code>.<br>
- Das sorgt f√ºr Typsicherheit und klare Bedingungen im Code.</p>

<h3>Zusammenfassungstabelle</h3>
<table border="1" cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Eigenschaft</th>
      <th>Beschreibung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Zweck</td>
      <td>Gruppierung von benannten konstanten Werten</td>
    </tr>
    <tr>
      <td>Typen</td>
      <td>Numerisch (Standard), String</td>
    </tr>
    <tr>
      <td>Werte</td>
      <td>Automatisch zugewiesen (Numerisch) oder manuell (String)</td>
    </tr>
    <tr>
      <td>Vorteile</td>
      <td>Lesbarkeit, Typsicherheit, Vermeidung von Tippfehlern</td>
    </tr>
    <tr>
      <td>Verwendung</td>
      <td>F√ºr Status, Optionen, Kategorien u.v.m.</td>
    </tr>
  </tbody>
</table>




</body>
</html>