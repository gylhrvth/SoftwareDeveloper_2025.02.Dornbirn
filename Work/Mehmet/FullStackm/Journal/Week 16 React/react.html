<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>
    <link rel="stylesheet" href="../../../MekStyle.css">
</head>
<style>
   

</style>
<body>
     <button id="mode-toggle">Light Mode</button>
    <h1>Node JS Notizen</h1>
    
    <ol id="Inhalt">
  <li>Woher kommt der Name "react"?</li>
  <li>Was ist ein JSX?</li>
  <li>Was ist ein Component?</li>
  <li>Wie erstelle ich eine einfache Component ohne Props?</li>
  <li>Wie füge ich className zu meinem JSX Elementen?</li>
  <li>Was sind Props?</li>
  <li>Wie erstelle ich eine Component mit Props?</li>
  <li>Wie verwende ich Props in meinem JSX Code?</li>
  <li>Kann ich einen Text / Zahl als Props übergeben?</li>
  <li>Kann ich ein oder mehrere className als Props übergeben?</li>
  <li>Welche Daten kann ich als Props übergeben?</li>
  <li>Kann ich einen EventHandler als Props übergeben?</li>
  <li>Kann ich einen EventHandler (die Zusatzinformation per Parameter bekommen wird) als Props übergeben?</li>
  <li>Wie schreibe ich eine Schleife in JSX?</li>
  <li>Wie schreibe ich eine if-Bedingung in JSX?</li>
    
    </ol>

<!-- Frage 1  -->
<section>
  <h2>1. Woher kommt der Name "React"?</h2>
  <p>Der Name <code>React</code> kommt von der zentralen Idee der Bibliothek: <strong>"Reagieren"</strong> auf Änderungen im Benutzerinterface (UI).</p>
  <p>React wurde entwickelt, um Benutzeroberflächen dynamisch und effizient zu aktualisieren, wenn sich Daten ändern. Das bedeutet, die UI <em>reagiert</em> automatisch auf Zustandsänderungen.</p>
  <ul>
    <li>React <strong>reagiert</strong> auf State- und Prop-Änderungen und aktualisiert die Darstellung automatisch.</li>
    <li>Der Name beschreibt die Idee der reaktiven Programmierung, bei der das UI sich automatisch anpasst.</li>
    <li>Facebook veröffentlichte React 2013, um effizientere und wartbare UIs zu ermöglichen.</li>
  </ul>
  <p>Zusammengefasst: <code>React</code> bedeutet, dass das UI intelligent und automatisch <strong>reagiert</strong> – das ist die Kernidee hinter dem Namen.</p>
</section>
    <section>
   
<!-- frage 2 -->
 <section>
  <h2>2. Was ist ein JSX?</h2>
  <p>
    JSX (JavaScript XML) ist eine Syntaxerweiterung für JavaScript, die es ermöglicht, HTML-ähnliche Strukturen direkt im JavaScript-Code zu schreiben. React nutzt JSX, um die Benutzeroberfläche (UI) zu definieren. Obwohl es aussieht wie HTML, wird JSX von React in JavaScript-Funktionen umgewandelt.
  </p>
  <p>
    Vorteile von JSX:
  </p>
  <ul>
    <li>Erleichtert das Schreiben von UI-Strukturen</li>
    <li>Erlaubt die Einbettung von JavaScript-Ausdrücken</li>
    <li>Verbessert die Lesbarkeit und Wartbarkeit des Codes</li>
  </ul>
<h3>Beispiele:</h3>
<p>React wandelt dies intern so um:</p>
<pre><code>
// Einfaches JSX-Element
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;

// Äquivalente JavaScript-Funktion = React wandelt JSX in JavaScript um
const element = React.createElement('h1', null, 'Hello, world!'); 

// JSX mit JavaScript-Ausdruck
const name = 'Maria';
const greeting = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;

// JSX mit Bedingung (ternärer Operator)
const isLoggedIn = true;
const message = &lt;div&gt;{isLoggedIn ? 'Willkommen zurück!' : 'Bitte anmelden'}&lt;/div&gt;

// JSX mit Schleife (Array.map)
const items = ['Apfel', 'Banane', 'Kirsche'];
const list = (
  &lt;ul&gt;
    {items.map(item =&gt; &lt;li key={item}&gt;{item}&lt;/li&gt;)}
  &lt;/ul&gt;
);
</code></pre>

  <h3>Zusammenfassung</h3>
  <table>
    <thead>
      <tr>
        <th>Konzept</th>
        <th>Beschreibung</th>
        <th>Beispiel</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>JSX</td>
        <td>HTML-ähnliche Syntax für JavaScript in React</td>
        <td>&lt;h1&gt;Hello, world!&lt;/h1&gt;</td>
      </tr>
      <tr>
        <td>JavaScript-Ausdruck</td>
        <td>Variablen und Ausdrücke in JSX verwenden</td>
        <td>{'{name}'} im &lt;h1&gt;-Tag</td>
      </tr>
      <tr>
        <td>Bedingung</td>
        <td>JSX mit if-else über ternären Operator</td>
        <td>{'{isLoggedIn ? "Willkommen zurück!" : "Bitte anmelden"}'}</td>
      </tr>
      <tr>
        <td>Schleife</td>
        <td>Array.map zum Rendern von Listen</td>
        <td>{'items.map(item => <li key={item}>{item}</li>)'}</td>
      </tr>
    </tbody>
  </table>
</section>

<!-- frage 3 -->
<section>
  <h2>3. Was ist ein Component?</h2>
  <p>
    In React ist ein <strong>Component</strong> das Herzstück, um wiederverwendbare und strukturierte Benutzeroberflächen zu bauen. Man kann sich Components wie Bausteine vorstellen, aus denen eine Webseite oder App zusammengesetzt wird.
  </p>
  <p>
    <strong>Components kapseln</strong> einen Teil der UI (Benutzeroberfläche) und die dazugehörige Logik, sodass sie isoliert, wiederverwendbar und leicht wartbar sind.
  </p>
  
  <h3>Warum Components?</h3>
  <ul>
    <li>
      <strong>Wiederverwendbarkeit:</strong>  
      Du schreibst ein Component einmal und kannst es überall in deiner App verwenden.
    </li>
    <li>
      <strong>Übersichtlichkeit:</strong>  
      UI wird in kleine, überschaubare Teile aufgeteilt, was den Code sauber und verständlich hält.
    </li>
    <li>
      <strong>Kapselung:</strong>  
      Jedes Component hat seinen eigenen Zustand (State) und Logik, die nicht unkontrolliert in der App verstreut sind.
    </li>
    <li>
      <strong>Komposition:</strong>  
      Komponenten können andere Komponenten enthalten (wie Lego-Steine).
    </li>
  </ul>
  
  <h3>Arten von Components</h3>
  <ol>
    <li>
      <strong>Functional Components (Funktionale Components)</strong><br>
      Sie sind einfache JavaScript-Funktionen, die JSX zurückgeben.
    </li>
    <li>
      <strong>Class Components (Klassen-Components)</strong><br>
      Sind JavaScript-Klassen, die von <code>React.Component</code> erben und eine <code>render()</code>-Methode besitzen.
    </li>
  </ol>
  <p>Heute werden funktionale Components bevorzugt, besonders mit React Hooks.</p>
  
  <h3>Einfaches Beispiel: Funktionales Component</h3>
  <pre><code>
function Welcome() {
  return &lt;h1&gt;Willkommen zu React!&lt;/h1&gt;;
}
  </code></pre>
  <p>Dieses Component gibt eine Überschrift zurück. Du kannst es wie ein HTML-Tag verwenden:</p>
  <pre><code>
&lt;Welcome /&gt;
  </code></pre>
  
  <h3>Beispiel mit Props (Datenübergabe)</h3>
  <pre><code>
function Welcome(props) {
  return &lt;h1&gt;Willkommen, {props.name}!&lt;/h1&gt;;
}

// Verwendung:
&lt;Welcome name="Maria" /&gt;
  </code></pre>
  <p>Hier zeigt das Component den Namen an, der als Prop übergeben wurde.</p>
  
  <h3>Zusammenfassung in Tabelle</h3>
  <table>
    <thead>
      <tr>
        <th>Begriff</th>
        <th>Erklärung</th>
        <th>Beispiel</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Component</td>
        <td>Wiederverwendbarer Baustein der UI, kapselt Layout und Logik</td>
        <td><code>function Welcome() { return &lt;h1&gt;Hello&lt;/h1&gt;; }</code></td>
      </tr>
      <tr>
        <td>Functional Component</td>
        <td>Funktion, die JSX zurückgibt</td>
        <td><code>const Welcome = () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;;</code></td>
      </tr>
      <tr>
        <td>Class Component</td>
        <td>Klasse mit <code>render()</code>-Methode, älterer Stil</td>
        <td><code>class Welcome extends React.Component { ... }</code></td>
      </tr>
      <tr>
        <td>Props</td>
        <td>Eigenschaften/Daten, die an Components übergeben werden</td>
        <td><code>&lt;Welcome name="Maria" /&gt;</code></td>
      </tr>
      <tr>
        <td>State</td>
        <td>Interner Zustand eines Components, der sich ändern kann</td>
        <td><code>const [count, setCount] = useState(0);</code></td>
      </tr>
      <tr>
        <td>Wiederverwendbarkeit</td>
        <td>Components können an mehreren Stellen genutzt werden</td>
        <td><code>&lt;Welcome /&gt; überall in der App</code></td>
      </tr>
      <tr>
        <td>Komposition</td>
        <td>Components können andere Components enthalten</td>
        <td><code>&lt;App&gt;&lt;Welcome /&gt;&lt;/App&gt;</code></td>
      </tr>
    </tbody>
  </table>
</section>

<!-- frage 4 -->
<section>
  <h2>4. Wie erstelle ich eine einfache Component ohne Props? (Und was ist mit Props?)</h2>
  <p>
    In React kannst du Components als JavaScript-Funktionen schreiben, die UI zurückgeben. 
    Es gibt zwei grundlegende Varianten:
  </p>
  <ol>
    <li><strong>Component ohne Props:</strong> Keine Eingabedaten, gibt immer denselben statischen Inhalt zurück.</li>
    <li><strong>Component mit Props:</strong> Nimmt ein <code>props</code>-Objekt entgegen, um dynamische Inhalte anzuzeigen.</li>
  </ol>

  <h3>Was ist das <code>props</code>-Objekt?</h3>
  <p>
    <code>props</code> ist ein Objekt, das alle Daten enthält, die du von außen an dein Component übergibst. 
    Du kannst damit dynamisch Inhalte darstellen, indem du z.B. <code>props.name</code> verwendest.
  </p>
  
  <h3>Beispiele</h3>
  <pre><code>
// Component ohne Props (keine Parameter)
function Greeting() {
  return &lt;h1&gt;Hallo, Welt!&lt;/h1&gt;;
}

// Component mit Props (props ist ein Objekt)
function GreetingWithProps(props) {
  return &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;;
}

// Beispiel für Arrow Function ohne Props
const GreetingArrow = () =&gt; &lt;h1&gt;Hallo, Welt!&lt;/h1&gt;;

// Arrow Function mit Props
const GreetingWithPropsArrow = (props) =&gt; &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;;
  </code></pre>

  <h3>Verwendung im JSX</h3>
  <pre><code>
&lt;Greeting /&gt;                        // Zeigt "Hallo, Welt!"
&lt;GreetingWithProps name="Maria" /&gt; // Zeigt "Hallo, Maria!"
  </code></pre>

  <h3>Wann solltest du welche Variante verwenden?</h3>
  <ul>
    <li><strong>Ohne Props:</strong> Wenn der Inhalt immer gleich ist und keine Anpassungen benötigt werden (z.B. statische Überschriften, einfache Buttons).</li>
    <li><strong>Mit Props:</strong> Wenn du Daten von außen reinreichen möchtest, um das Component flexibel und wiederverwendbar zu machen.</li>
    <li><strong>Arrow Function vs. normale Funktion:</strong> Beide sind möglich, Arrow Functions sind kürzer und oft moderner, normal Functions können besser in bestimmten Fällen wie hoisting oder Methoden verwendet werden.</li>
  </ul>

  <h3>Kurzzusammenfassung in Tabelle</h3>
  <table>
    <thead>
      <tr>
        <th>Variante</th>
        <th>Beschreibung</th>
        <th>Syntax-Beispiel</th>
        <th>Wann nutzen?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Component ohne Props (Funktion)</td>
        <td>Gibt immer statischen UI-Inhalt zurück</td>
        <td><code>function Greeting() { return &lt;h1&gt;Hallo&lt;/h1&gt;; }</code></td>
        <td>Statische UI, einfache Elemente</td>
      </tr>
      <tr>
        <td>Component mit Props (Funktion)</td>
        <td>Nimmt ein props-Objekt für dynamische Inhalte</td>
        <td><code>function Greeting(props) { return &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;; }</code></td>
        <td>Dynamische, anpassbare UI</td>
      </tr>
      <tr>
        <td>Component ohne Props (Arrow Function)</td>
        <td>Kürzere Syntax, statische UI</td>
        <td><code>const Greeting = () =&gt; &lt;h1&gt;Hallo&lt;/h1&gt;;</code></td>
        <td>Kurze, einfache Components</td>
      </tr>
      <tr>
        <td>Component mit Props (Arrow Function)</td>
        <td>Kürzere Syntax mit props-Objekt</td>
        <td><code>const Greeting = (props) =&gt; &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;;</code></td>
        <td>Dynamische Components mit einfachem Code</td>
      </tr>
    </tbody>
  </table>
</section>

<!-- frage 5 -->
 <section>
  <h2>5. Wie füge ich <code>className</code> zu meinem JSX-Elementen hinzu?</h2>
  <p>
    In React verwendest du <code>className</code> statt <code>class</code>, um CSS-Klassen an JSX-Elemente zu vergeben. 
    Das liegt daran, dass <code>class</code> ein reserviertes Schlüsselwort in JavaScript ist. React nutzt deshalb <code>className</code> als Alternative.
  </p>
  <h3>Was ist <code>className</code>?</h3>
  <p>
    <code>className</code> ist das JSX-Attribut, mit dem du einem Element CSS-Klassen zuweist, ähnlich wie <code>class</code> im HTML. React wandelt <code>className</code> intern beim Rendern in das HTML-Attribut <code>class</code> um.
  </p>
  <h3>Einfaches Beispiel</h3>
  <pre><code>
function Box() {
  return &lt;div className="box shadow"&gt;Inhalt&lt;/div&gt;;
}
  </code></pre>
  <p>Wird im Browser zu:</p>
  <pre><code>
&lt;div class="box shadow"&gt;Inhalt&lt;/div&gt;
  </code></pre>
  <h3>Dynamische Klassen mit Bedingungen</h3>
  <pre><code>
function Button({ isActive }) {
  return (
    &lt;button className={isActive ? "btn active" : "btn"}&gt;
      Klick mich
    &lt;/button&gt;
  );
}
  </code></pre>
  <h3>Wann benutzt man <code>className</code>?</h3>
  <ul>
    <li>Immer, wenn du CSS-Klassen in JSX hinzufügen willst.</li>
    <li>Für Styling, Layout, Animationen oder visuelle Effekte.</li>
    <li>Es ersetzt das HTML-Attribut <code>class</code> in React-Komponenten.</li>
  </ul>
  <h3>Zusammenfassung</h3>
  <table>
    <thead>
      <tr>
        <th>Begriff</th>
        <th>Erklärung</th>
        <th>Beispiel JSX</th>
        <th>HTML entspricht</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>class</code></td>
        <td>HTML-Attribut für CSS-Klassen (in React nicht erlaubt)</td>
        <td><code>&lt;div class="box"&gt;</code> (falsch in JSX)</td>
        <td><code>&lt;div class="box"&gt;</code></td>
      </tr>
      <tr>
        <td><code>className</code></td>
        <td>JSX-Attribut für CSS-Klassen (React-spezifisch)</td>
        <td><code>&lt;div className="box shadow"&gt;</code></td>
        <td><code>&lt;div class="box shadow"&gt;</code></td>
      </tr>
      <tr>
        <td>Dynamische Klassen</td>
        <td>Klassen, die sich je nach Zustand oder Props ändern</td>
        <td><code>&lt;button className={isActive ? "btn active" : "btn"}&gt;</code></td>
        <td>JS-generierte Klassen im HTML</td>
      </tr>
    </tbody>
  </table>
</section>

<!-- honrable mention hallo oder Hallo -->
 <section>
  <h2>Unterschied zwischen <code>{hallo()}</code> und <code>&lt;Hallo /&gt;</code> in React</h2>
  <p>Hier erkläre ich dir, was der Unterschied ist und wann du welche Variante verwenden solltest.</p>
  
  <h3>1. <code>{hallo()}</code> – Direkter Funktionsaufruf im JSX</h3>
  <p>Du rufst die Funktion <code>hallo</code> einfach als normale JavaScript-Funktion auf, die JSX zurückgibt. Das Ergebnis wird dann an dieser Stelle im UI eingefügt.</p>
  <pre><code>
const hallo = () =&gt; &lt;h1&gt;Hallo Welt&lt;/h1&gt;;

function MyApp() {
  return (
    &lt;div&gt;
      {hallo()}  {/* Funktion wird hier ausgeführt */}
    &lt;/div&gt;
  );
}
  </code></pre>

  <h3>2. <code>&lt;Hallo /&gt;</code> – Component als JSX-Tag</h3>
  <p>Du definierst <code>Hallo</code> als React-Komponente (großgeschriebener Funktionsname) und verwendest sie als JSX-Tag. React rendert dann das Component an dieser Stelle.</p>
  <pre><code>
function Hallo() {
  return &lt;h1&gt;Hallo Welt&lt;/h1&gt;;
}

function MyApp() {
  return (
    &lt;div&gt;
      &lt;Hallo /&gt;  {/* Component wird hier gerendert */}
    &lt;/div&gt;
  );
}
  </code></pre>

  <h3>Unterschiede &amp; Empfehlung</h3>
  <ul>
    <li><strong>{hallo()}</strong> ist ein einfacher Funktionsaufruf – gut für kleine JSX-Fragmente oder wenn keine State/Props verwendet werden.</li>
    <li><strong>&lt;Hallo /&gt;</strong> ist eine React-Komponente – empfohlen für wiederverwendbare UI-Bausteine mit eigenem Zustand, Props oder Lifecycle.</li>
    <li>React erwartet Components, die mit einem Großbuchstaben beginnen (z.B. <code>Hallo</code>), damit sie als JSX-Tags funktionieren.</li>
  </ul>
</section>

 <!-- frage 6 -->
 <section>
  <h2>6. Was sind Props?</h2>

  <p>
    <strong>Props</strong> (kurz für <em>Properties</em>) sind die Daten, die du von einem übergeordneten React-Komponent (Parent) an ein untergeordnetes (Child) weitergibst. Man kann Props sich als <strong>Parameter</strong> vorstellen, die an Funktionen übergeben werden — nur eben speziell für React-Komponenten.
  </p>

  <p>
    Props sind immer <strong>Objekte</strong>, die alle übergebenen Werte als Eigenschaften enthalten. Das erlaubt dir, mehrere Daten in einem einzigen Objekt zu bündeln und an das Kind-Komponent zu senden.
  </p>

  <h3>Warum Props?</h3>
  <ul>
    <li>Sie ermöglichen <strong>Kommunikation zwischen Komponenten</strong>.</li>
    <li>Machen Komponenten <strong>wiederverwendbar</strong> und <strong>flexibel</strong>.</li>
    <li>Halten Datenfluss <strong>einfach und übersichtlich</strong>: Props fließen nur von Parent zu Child (unidirektional).</li>
    <li>Komponenten sind so leichter zu testen und zu pflegen.</li>
  </ul>

  <h3>Beispiel: Props als Objekt</h3>
  <pre><code>
function Welcome(props) {
  // props ist ein Objekt, z.B. { name: "Maria", age: 25, isLoggedIn: true }
  return (
    &lt;div&gt;
      &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;
      &lt;p&gt;Alter: {props.age}&lt;/p&gt;
      &lt;p&gt;Status: {props.isLoggedIn ? "Eingeloggt" : "Gast"}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Verwendung des Components mit Props
&lt;Welcome name="Maria" age={25} isLoggedIn={true} /&gt;
  </code></pre>

  <h3>Props mit Destructuring (modern &amp; sauber)</h3>
  <pre><code>
function Welcome({ name, age, isLoggedIn }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hallo, {name}!&lt;/h1&gt;
      &lt;p&gt;Alter: {age}&lt;/p&gt;
      &lt;p&gt;Status: {isLoggedIn ? "Eingeloggt" : "Gast"}&lt;/p&gt;
    &lt;/div&gt;
  );
}
  </code></pre>

  <h3>Was kannst du mit Props machen?</h3>
  <ul>
    <li>Strings, Zahlen, Booleans: einfache Daten.</li>
    <li>Objekte und Arrays: komplexe Strukturen.</li>
    <li>Funktionen: z.B. Callback-Funktionen für Events.</li>
    <li>JSX/Components: Props können auch React-Elemente oder Components enthalten.</li>
  </ul>

  <h3>Beispiel mit Funktion als Prop (Callback)</h3>
  <pre><code>
function Button({ onClick, label }) {
  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;
}

function App() {
  const handleClick = () =&gt; alert("Button wurde geklickt!");

  return &lt;Button onClick={handleClick} label="Klick mich!" /&gt;;
}
  </code></pre>

  <h3>Tabelle: Props vs Kein Props vs Arrow Function vs normale Funktion</h3>
  <table>
    <thead>
      <tr>
        <th>Variante</th>
        <th>Syntax Beispiel</th>
        <th>Wann verwenden?</th>
        <th>Vorteile</th>
        <th>Nachteile</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Ohne Props</td>
        <td><code>function Hello() { return &lt;h1&gt;Hi&lt;/h1&gt;; }</code></td>
        <td>Statische UI, keine Daten nötig</td>
        <td>Einfach, schnell</td>
        <td>Nicht flexibel</td>
      </tr>
      <tr>
        <td>Mit Props</td>
        <td><code>function Hello(props) { return &lt;h1&gt;{props.name}&lt;/h1&gt;; }</code></td>
        <td>Dynamische UI, externe Daten</td>
        <td>Wiederverwendbar, flexibel</td>
        <td>Props müssen korrekt übergeben werden</td>
      </tr>
      <tr>
        <td>Arrow Function ohne Props</td>
        <td><code>const Hello = () =&gt; &lt;h1&gt;Hi&lt;/h1&gt;;</code></td>
        <td>Kurze Komponenten ohne Props</td>
        <td>Kurz, prägnant</td>
        <td>Nicht für komplexe Logik</td>
      </tr>
      <tr>
        <td>Arrow Function mit Props</td>
        <td><code>const Hello = ({name}) =&gt; &lt;h1&gt;{name}&lt;/h1&gt;;</code></td>
        <td>Dynamische UI, moderne Schreibweise</td>
        <td>Kürzer, übersichtlich</td>
        <td>Manchmal schwerer zu debuggen</td>
      </tr>
    </tbody>
  </table>

  <h3>Fazit</h3>
  <p>
    Props sind Objekte, die Daten von Parent zu Child Komponenten transportieren. Sie machen deine UI dynamisch und wiederverwendbar. Nutze Props, wenn dein Component Informationen von außen benötigt. Du kannst einfache oder komplexe Daten, Funktionen und sogar JSX als Props übergeben.
  </p>
</section>

<!-- frage 7 -->
<section>
  <h2>Wie erstelle ich eine Component mit Props?</h2>
  <p>
    Props (Properties) sind Daten, die du an ein React-Component übergibst, damit es dynamisch und wiederverwendbar wird.
    Eine Component mit Props ist eine Funktion, die ein Objekt <code>props</code> als Parameter erhält. Dieses Objekt enthält alle übergebenen Werte.
  </p>
  <h3>Grundidee:</h3>
  <ul>
    <li><code>props</code> ist ein Objekt mit Eigenschaften.</li>
    <li>Du kannst auf diese Eigenschaften im Component zugreifen, um Inhalte dynamisch anzuzeigen.</li>
    <li>Props ermöglichen, dass ein Component flexibel auf unterschiedliche Eingaben reagiert.</li>
  </ul>

  <h3>Beispiel: Component mit Props</h3>
  <pre><code>
function Welcome(props) {
  return &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;;
}

// Verwendung:
&lt;Welcome name="Maria" /&gt;
  </code></pre>

  <h3>Modernere Variante mit Destructuring</h3>
  <pre><code>
function Welcome({ name }) {
  return &lt;h1&gt;Hallo, {name}!&lt;/h1&gt;;
}
  </code></pre>

  <h3>Warum Props verwenden?</h3>
  <ul>
    <li>Komponenten werden wiederverwendbar.</li>
    <li>Du kannst dynamisch Inhalte darstellen.</li>
    <li>Bessere Trennung von Daten und UI.</li>
    <li>Einfaches Weitergeben von Daten oder Funktionen an Child-Komponenten.</li>
  </ul>

  <h3>Weiteres Beispiel mit mehreren Props und Funktionen:</h3>
  <pre><code>
function UserCard({ name, age, onClick }) {
  return (
    &lt;div onClick={onClick}&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;
      &lt;p&gt;Alter: {age}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Verwendung
&lt;UserCard name="Anna" age={30} onClick={() =&gt; alert("Karte geklickt!")} /&gt;
  </code></pre>

  <h3>Zusammenfassung</h3>
  <table>
    <thead>
      <tr>
        <th>Punkt</th>
        <th>Erklärung</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Props</td>
        <td>Objekt mit Daten, die an Components übergeben werden</td>
      </tr>
      <tr>
        <td>Zugriff auf Props</td>
        <td><code>props.propName</code> oder Destructuring <code>{'{ propName }'}</code></td>
      </tr>
      <tr>
        <td>Zweck</td>
        <td>Dynamische, wiederverwendbare UI</td>
      </tr>
      <tr>
        <td>Übergabe</td>
        <td><code>&lt;Component propName="Wert" /&gt;</code></td>
      </tr>
      <tr>
        <td>Props können sein</td>
        <td>Strings, Zahlen, Booleans, Objekte, Funktionen, JSX-Elemente</td>
      </tr>
    </tbody>
  </table>
</section>

<!-- Warum export honorable mention? -->
<section>
  <h2>HONORABLE INFO. React Komponenten: Export, Default und Sichtbarkeit im Web — Ultimativer Guide</h2>

  <h3>1. Was ist <code>export</code> und <code>export default</code>?</h3>
  <p>
    <code>export</code> macht Funktionen oder Komponenten aus einer Datei für andere Dateien verfügbar.<br/>
    <code>export default</code> kennzeichnet eine einzelne Haupt-Komponente als Standard-Export.
  </p>

  <h3>2. Warum braucht React eine Root-Komponente (<code>export default</code>)?</h3>
  <p>
    React rendert immer eine einzige Root-Komponente, meist <code>App</code> genannt.<br/>
    Diese Root-Komponente ist der Einstiegspunkt für die gesamte Webseite.<br/>
    Deshalb wird sie mit <code>export default</code> exportiert.
  </p>

  <h3>3. Wie erscheinen Komponenten im Web?</h3>
  <ul>
    <li>Komponenten sind nur sichtbar, wenn sie in der Root-Komponente oder deren Kind-Komponenten im JSX auftauchen.</li>
    <li>Ob sie aus derselben Datei oder importiert stammen, ist egal.</li>
    <li>Exportieren macht Komponenten nicht automatisch sichtbar.</li>
  </ul>

  <h3>4. Muss ich alle Komponenten <code>export</code> machen?</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Situation</th>
        <th>Muss exportiert werden?</th>
        <th>Muss in <code>export default</code> rein?</th>
        <th>Sichtbar im Web?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Komponente nur in derselben Datei</td>
        <td>Nein</td>
        <td>Nein</td>
        <td>Ja, wenn in JSX der Root-Komponente verwendet</td>
      </tr>
      <tr>
        <td>Komponente in anderer Datei</td>
        <td>Ja (<code>export</code> oder <code>export default</code>)</td>
        <td>Nein</td>
        <td>Ja, wenn importiert und in JSX der Root-Komponente verwendet</td>
      </tr>
      <tr>
        <td>Root-Komponente (z.B. <code>App</code>)</td>
        <td>Ja, <code>export default</code></td>
        <td>Ja</td>
        <td>Ja, wird von React als Einstiegspunkt gerendert</td>
      </tr>
    </tbody>
  </table>

  <h3>5. Unterschied <code>export</code> vs. <code>export default</code></h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th><code>export</code></th>
        <th><code>export default</code></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Mehrere Exporte pro Datei möglich</td>
        <td>Nur ein Default-Export pro Datei</td>
      </tr>
      <tr>
        <td>Import mit geschweiften Klammern:<br/><code>import { Component } from './Datei';</code></td>
        <td>Import ohne Klammern:<br/><code>import Component from './Datei';</code></td>
      </tr>
      <tr>
        <td>Gut für viele kleine Komponenten in einer Datei</td>
        <td>Ideal für die Haupt-Komponente (Root)</td>
      </tr>
    </tbody>
  </table>

  <h3>6. Beispiele</h3>
  <h4>a) Komponente ohne Export (nur intern)</h4>
  <pre><code>
function Button() {
  return &lt;button&gt;Klick mich&lt;/button&gt;;
}

export default function App() {
  return (
    &lt;div&gt;
      &lt;Button /&gt; {/* Button wird sichtbar */}
    &lt;/div&gt;
  );
}
  </code></pre>

  <h4>b) Komponente exportieren und importieren</h4>
  <pre><code>
// Button.js
export function Button() {
  return &lt;button&gt;Klick mich&lt;/button&gt;;
}

// App.js
import { Button } from './Button';

export default function App() {
  return (
    &lt;div&gt;
      &lt;Button /&gt; {/* sichtbar durch Import und JSX */}
    &lt;/div&gt;
  );
}
  </code></pre>

  <h4>c) Root-Komponente exportieren</h4>
  <pre><code>
export default function App() {
  return &lt;h1&gt;Meine App&lt;/h1&gt;;
}
  </code></pre>

  <h3>7. Fazit</h3>
  <ul>
    <li>React rendert immer eine einzelne Root-Komponente (meist <code>App</code>), die mit <code>export default</code> exportiert wird.</li>
    <li>Nur Komponenten, die im JSX dieser Root-Komponente auftauchen, sind sichtbar.</li>
    <li>Komponenten in derselben Datei brauchen kein Export, wenn sie nur intern verwendet werden.</li>
    <li>Komponenten aus anderen Dateien müssen exportiert und importiert werden, damit sie genutzt werden können.</li>
    <li>Exportieren macht Komponenten verfügbar, aber nicht automatisch sichtbar.</li>
  </ul>

  <h3>8. Bonus: Unterschied &lt;Component /&gt; vs. {`{Component()}`}</h3>
  <p>
    <code>{`{Component()}`}</code> ruft die Funktion direkt auf und rendert das Ergebnis.<br/>
    <code>&lt;Component /&gt;</code> ist JSX-Syntax und hat Vorteile wie Props, Lifecycle und Hooks.<br/>
    In React solltest du immer <code>&lt;Component /&gt;</code> benutzen für bessere Lesbarkeit und Funktionalität.
  </p>
</section>

<!-- frage 8  -->
<section>
  <h2>8. Wie verwende Props in mein JSX Code?</h2>
  <p>
    Props (Properties) sind Daten, die du von außen an eine React-Komponente übergibst, damit sie dynamisch Inhalte anzeigen kann.
  </p>

  <h3>1. Props empfangen</h3>
  <pre><code>
function Greeting(props) {
  return &lt;h1&gt;Hallo, {props.name}!&lt;/h1&gt;;
}
  </code></pre>

  <h3>2. Props übergeben</h3>
  <pre><code>
&lt;Greeting name="Mehmet" /&gt;
  </code></pre>

  <h3>3. Props sind Objekte</h3>
  <p>
    Das <code>props</code>-Objekt enthält alle übergebenen Werte, z.B. <code>{'{ name: "Mehmet", age: 25 }'}</code>.
    Du greifst mit <code>props.name</code> oder <code>props.age</code> darauf zu.
  </p>

  <h3>4. Destructuring (Entpacken)</h3>
  <pre><code>
function Greeting({ name }) {
  return &lt;h1&gt;Hallo, {name}!&lt;/h1&gt;;
}
  </code></pre>

  <h3>5. Props können alles sein</h3>
  <p>Strings, Zahlen, Funktionen, Objekte, Arrays – alles kann als Prop übergeben werden.</p>

  <h4>Beispiel komplett:</h4>
  <pre><code>
function Greeting({ name, age }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hallo, {name}!&lt;/h1&gt;
      &lt;p&gt;Du bist {age} Jahre alt.&lt;/p&gt;
    &lt;/div&gt;
  );
}

&lt;Greeting name="Mehmet" age={25} /&gt;
  </code></pre>
</section> 

<!-- Frage 9 -->

<section>
  <h2>9. Kann ich einen Text / Zahl als Props übergeben?</h2>
  <p>In React kannst du ganz normal Text (Strings) und Zahlen (Numbers) als Props an Komponenten übergeben.</p>
  
  <h3>Wie funktioniert das?</h3>
  <ul>
    <li><strong>Text (String):</strong> Übergibst du in Anführungszeichen, z.B. <code>&lt;Greeting name="Mehmet" /&gt;</code></li>
    <li><strong>Zahl (Number):</strong> Übergibst du in geschweiften Klammern, z.B. <code>&lt;Greeting age={25} /&gt;</code></li>
  </ul>

  <h3>Beispiel-Code:</h3>
  <pre><code>
function Greeting({ name, age }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hallo, {name}!&lt;/h1&gt;
      &lt;p&gt;Du bist {age} Jahre alt.&lt;/p&gt;
    &lt;/div&gt;
  );
}

&lt;Greeting name="Mehmet" age={25} /&gt;
  </code></pre>

  <h3>Warum so?</h3>
  <p>
    Strings werden in Anführungszeichen geschrieben, weil sie Text sind. Zahlen (oder andere JavaScript-Ausdrücke) müssen in <code>{ }</code> stehen, damit React sie als Wert und nicht als Text interpretiert.
  </p>

  <h3>Zusammenfassung:</h3>
  <table>
    <thead>
      <tr>
        <th>Prop-Typ</th>
        <th>Übergabe im JSX</th>
        <th>Zugriff in Komponente</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Text (String)</td>
        <td><code>&lt;Component prop="text" /&gt;</code></td>
        <td><code>props.prop</code> oder <code>{'{ prop }'}</code></td>
      </tr>
      <tr>
        <td>Zahl (Number)</td>
        <td><code>&lt;Component prop={'{123}'} /&gt;</code></td>
        <td><code>props.prop</code> oder <code>{'{ prop }'}</code></td>
      </tr>
    </tbody>
  </table>
</section>

<!-- frage 10  -->
<section>
  <h2>10. Kann ich ein oder mehrere <code>className</code> als Props übergeben?</h2>
  <p>
    Ja, du kannst <code>className</code> (also CSS-Klassen) als Props an eine React-Komponente übergeben und sie dann auf das gewünschte JSX-Element anwenden. 
    Das macht deine Komponente flexibler, weil du das Styling von außen steuern kannst.
  </p>

  <h3>1. Warum <code>className</code> als Prop?</h3>
  <ul>
    <li>In React nutzt man statt <code>class</code> das Attribut <code>className</code>, weil <code>class</code> in JavaScript reserviert ist.</li>
    <li>Wenn du <code>className</code> über Props übergibst, kannst du einer Komponente verschiedene CSS-Klassen zuweisen, ohne den Komponentencode selbst anzupassen.</li>
    <li>Du gewinnst Wiederverwendbarkeit: Ein und dieselbe Komponente kann in unterschiedlichen Kontexten mit unterschiedlichen Styles auftauchen.</li>
  </ul>

  <h3>2. Grundlegender Aufbau</h3>
  <p>
    1. <strong>Props definieren und destrukturieren:</strong><br/>
    In der Komponente nimmst du <code>className</code> als Teil des <code>props</code>-Objekts entgegen:
  </p>
  <pre><code>
function Button({ className, children }) {
  return &lt;button className={className}&gt;
    {children}
  &lt;/button&gt;
}
  </code></pre>
  <p>
    Hier ist <code>className</code> eine Prop, und <code>children</code> repräsentiert den Text oder andere JSX-Inhalte, die du zwischen den Tags übergeben kannst.
  </p>
  <p>
    2. <strong>Props übergeben:</strong><br/>
    Wenn du die Komponente verwendest, übergibst du <code>className</code> als String—entweder eine einzelne CSS-Klasse oder mehrere Klassen, durch Leerzeichen getrennt:
  </p>
  <pre><code>
&lt;Button className="primary"&gt;Klick mich&lt;/Button&gt;
&lt;Button className="primary large"&gt;Klick mich&lt;/Button&gt;
  </code></pre>

  <h3>3. Beispiel mit mehreren <code>className</code>-Werten</h3>
  <pre><code>
function Button({ className, onClick, children }) {
  return (
    &lt;button className={className} onClick={onClick}&gt;
      {children}
    &lt;/button&gt;
  );
}

// Verwendung in der App:
&lt;Button className="primary" onClick={() =&gt; alert('Hi!')&gt;
  Primärbutton
&lt;/Button&gt;

&lt;Button className="primary large" onClick={() =&gt; alert('Großer Button')&gt;
  Großer Button
&lt;/Button&gt;

&lt;Button className="primary disabled" onClick={() =&gt; null&gt;
  Deaktiviert
&lt;/Button&gt;
  </code></pre>
  <p>
    <em>primary</em> ist eine CSS-Klasse, die z.B. die Hintergrundfarbe definiert.
    <em>large</em> könnte eine zusätzliche Klasse sein, die Schriftgröße und Polsterung verändert.
    <em>disabled</em> lässt den Button ausgegraut erscheinen.
  </p>

  <h3>4. Dynamische Kombination von Klassen</h3>
  <pre><code>
function ToggleButton({ isActive, onClick }) {
  // Basis-Klasse
  let classes = "toggle-btn";

  // Wenn isActive true ist, füge "active" hinzu
  if (isActive) {
    classes += " active";
  }

  return (
    &lt;button className={classes} onClick={onClick}&gt;
      {isActive ? "An" : "Aus"}
    &lt;/button&gt;
  );
}

// In deiner App:
&lt;ToggleButton isActive={true} onClick={() =&gt; console.log("An")} /&gt;
&lt;ToggleButton isActive={false} onClick={() =&gt; console.log("Aus")} /&gt;
  </code></pre>
  <p>
    Hier besteht <code>classes</code> je nach Zustand aus <code>"toggle-btn active"</code> oder nur <code>"toggle-btn"</code>.
    Du übergibst <code>classes</code> als <code>className</code>-Prop an den Button.
  </p>

  <h3>5. Beschränkungen und Tipps</h3>
  <ul>
    <li><strong>Props sind <em>immutable</em>:</strong> Du veränderst <code>className</code> nicht innerhalb der Komponente, sondern kombinierst oder wählst es vorab aus, bevor du es übergibst.</li>
    <li><strong>Einzelne oder mehrere Klassen:</strong> Gib Klassen als reine Strings an. Mehrere Klassen trennst du durch Leerzeichen: <code>"classA classB classC"</code>.</li>
    <li><strong>Vermeide harte Codierung:</strong> Schreibe nicht im Komponent selbst <code>&lt;button className="primary"&gt;</code>, sondern übergebe immer <code>className</code> via Prop—so bleibt der Komponent wiederverwendbar.</li>
  </ul>

  <h3>6. Zusammenfassung in Tabelle</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Aufgabe</th>
        <th>Syntax-Beispiel</th>
        <th>Erklärung</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Einzelne Klasse übergeben</td>
        <td><code>&lt;Button className="primary"&gt;Text&lt;/Button&gt;</code></td>
        <td>Button bekommt die CSS-Klasse <em>primary</em>.</td>
      </tr>
      <tr>
        <td>Mehrere Klassen übergeben</td>
        <td><code>&lt;Button className="primary large"&gt;Text&lt;/Button&gt;</code></td>
        <td>Button erhält <em>primary</em> und <em>large</em>.</td>
      </tr>
      <tr>
        <td>Dynamische Klassen-Kombination</td>
        <td><code>const classes = isActive ? "btn active" : "btn";<br>&lt;Button className={classes}&gt;Text&lt;/Button&gt;</code></td>
        <td>Je nach Zustand kommt <em>active</em> dazu oder nicht.</td>
      </tr>
      <tr>
        <td>Komponente definiert</td>
        <td><code>function Button({ className, children }) {<br>&nbsp;&nbsp;return &lt;button className={className}&gt;{children}&lt;/button&gt;<br>}</code></td>
        <td><code>className</code> wird als Prop entgegengenommen und direkt auf das <code>&lt;button&gt;</code> angewendet.</td>
      </tr>
    </tbody>
  </table>

  <h3>7. Fazit</h3>
  <p>
    Du kannst beliebig viele Klassen als <code>className</code>-Prop übergeben, 
    indem du sie als String (mit Leerzeichen getrennt) an die Komponente weiterreichst. 
    Das macht deine Komponente flexibel und das Styling von außen steuerbar.
  </p>
</section>


<h2> </h2>

            <p></p>
            <p></p>
            <ul>
                <li></li>
                <li></li>
            </ul>
         <h2> </h2>
            <p></p>
            <p></p>
            <ul>
                <li></li>
                <li></li>
            </ul>
         <h2> </h2>
            <p></p>
            <p></p>
            <ul>
                <li></li>
                <li></li>
            </ul>
         <h2> </h2>
            <p></p>
            <p></p>
            <ul>
                <li></li>
                <li></li>
            </ul>
       

    </section>

      <script>
    const button = document.getElementById('mode-toggle');
    const body = document.body;

    button.addEventListener('click', () => {
      body.classList.toggle('light');
      const isLight = body.classList.contains('light');
      button.textContent = isLight ? 'Dark Mode' : 'Light Mode';
    });
    
  </script>  
</body>
</html>